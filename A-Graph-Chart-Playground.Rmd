---
title: "| Economic Stock Portfolio Analysis\n| \n| MySQL, Graph, and Chart Playground\n"
author: "Duane A. Murray"
date: "`r format(Sys.time(), '%d %B, %Y')`"
header-includes:
  - \usepackage{float}
  - \usepackage{pdflscape}
  - \floatplacement{figure}{H}
  - \usepackage{imakeidx}
  - \makeindex[intoc]
output: 
  pdf_book: 
    toc: true 
    toc_depth: 4
  pdf_document: 
    toc: true 
    toc_depth: 4
editor_options: 
  markdown: 
    wrap: 72
---

\newpage

```{r, include=FALSE, eval=FALSE}

# RUN THIS CHUNK TO GENERATE A BOOKDOWN PDF DOC, OTHERWISE, KNIT TO PDF
knitr::opts_chunk$set(echo = TRUE)
library(tinytex)
library(bookdown);
library(rmarkdown);
library(kableExtra);
rmarkdown::render("A-Graph-Chart-Playground.Rmd", "pdf_book")

```

```{r loadingPackages, include=FALSE, message=FALSE, warning=FALSE}
library(tinytex)
library(bookdown);
library(rmarkdown);

library(kableExtra, quietly=TRUE)
library(ROI, quietly=TRUE)             
library(ROI.plugin.glpk, quietly=TRUE) 
library(ompr, quietly=TRUE)            
library(ompr.roi, quietly=TRUE)
library(TRA, quietly=TRUE)
library(rsvg, quietly=TRUE)
library(DiagrammeR, quietly=TRUE)
library(DiagrammeRsvg, quietly=TRUE)
library(tidyverse, quietly=TRUE)
library(lessR, quietly=TRUE)
library(ggplot2, quietly=TRUE)
library(RMySQL, quietly=TRUE)
library (MultiplierDEA, quietly=TRUE)
options(digits = 2)

```

```{r configureParams, echo=FALSE, message=FALSE}

#################################
# AVAILABLE SECTORS:
# NAME                    COUNT
# ----------------------- -----
# Basic Materials		      304
# Communication Services	357
# Consumer Cyclical	      673
# Consumer Defensive	    285
# Energy			            325
# Financial Services	    3415
# Healthcare		          1541
# Industrials		          926
# Real Estate		          503
# Technology		          974
# Utilities		            146
#################################

SECTOR <- 'Energy'
FiscalYear <- '2017'
Quarter <- 'Q3'
MonthName <- 'September'

StartDate <- '2017-09-01'
EndDate <- '2017-09-29'

periodOneDate <- '2017-10-31'
periodTwoDate <- '2017-11-30'
periodThreeDate <- '2017-12-29'

############################

```

# `r SECTOR` Sector

```{r LoadDataMySQL, echo=FALSE, message=FALSE}

# CONNECT TO MYSQL DATABASE
mydb = dbConnect(MySQL(), 
                 user='vsc', 
                 password='blaster123', 
                 dbname='stockdata', 
                 host='127.0.0.1')

########################################################################
# QUERY ALL STOCK DEA INPUTS AND OUTPUTS, AND 1,3,6 MONTH FUTURE PRICES
########################################################################
sql_select <- sprintf("
SELECT 
	b.symbol AS 'DMU', 
	b.beta AS 'Beta', 
	b.sigma AS 'Sigma', 
	r.debtEquityRatio AS 'DToE', 
	r.priceToBookRatio AS 'PToB', 
	r.netProfitMargin AS 'NetMrgn',
  e.netIncomePerShare as 'EPS',
	r.returnOnAssets AS 'ROA', 
	r.returnOnEquity as 'ROE',
	b.StockReturnRate as 'TTMreturn',
  p.Close AS 'entryPrice',
  p.Close AS 'oneYRprice',
  p.Close AS 'threeYRprice',
  p.Close AS 'fiveYRprice',
  b.Sector AS 'Sector'
FROM 
	stockdata.company_beta_sigma b, 
	stockdata.company_ratios r,
  stockdata.company_eps_pe e,
  stockdata.equity_prices p
WHERE 
	b.Sector = '%s'
  AND monthname(b.StartDate) = '%s'
	AND b.Year = '%s'
	AND b.Quarter = '%s'
	AND r.calendarYear = '%s'
	AND r.Period = '%s'
  AND e.calendarYear = '%s'
  AND e.period = '%s'
	AND b.Symbol = r.Symbol
	AND p.Symbol = b.Symbol
  AND e.Symbol = b.Symbol
  AND b.beta != 0
	AND b.sigma != 0 
	AND r.debtEquityRatio != 0
	AND r.priceToBookRatio != 0
	AND r.netProfitMargin != 0
	AND e.netIncomePerShare != 0
	AND r.returnOnAssets != 0 
	AND r.returnOnEquity != 0
	AND b.StockReturnRate != 0
	AND p.Close != 0
  AND p.date = b.EndDate", 
SECTOR, MonthName, FiscalYear, Quarter, FiscalYear, Quarter,  FiscalYear, Quarter);

# RUN THE QUERY AND GET THE RESULTS
rs = dbSendQuery(mydb, sql_select)
df = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS

db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

# SET THE DMU NAMES
DMUnames <- df[,1] # ALL ROWS, COL 1

df_periodOnePrice <- data.frame()
df_periodTwoPrice <- data.frame()
df_periodThreePrice <- data.frame()

##########################################
# GET FUTURE PRICE DATA FOR BACKTESTING
##########################################
for (stock_symbol in DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", 
  stock_symbol, periodOneDate);

  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  df_periodOnePrice <- rbind(df_periodOnePrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

for (stock_symbol in DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", 
  stock_symbol, periodTwoDate);

  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  df_periodTwoPrice <- rbind(df_periodTwoPrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

for (stock_symbol in DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", 
  stock_symbol, periodThreeDate);

  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  df_periodThreePrice <- rbind(df_periodThreePrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

# BUILD THE BACKTESTING DATAFRAME FROM THE FUTURE PRICES
tempDataframe <- cbind(df[,1], df[,11])  # DMU AND ENTRY PRICE
colnames(tempDataframe) <- c("symbol","entry")
tempFuturePrices1 <- merge(tempDataframe, df_periodOnePrice, by="symbol")
tempFuturePrices2 <- merge(tempFuturePrices1, df_periodTwoPrice, by="symbol")
futurePrices <- merge(tempFuturePrices2, df_periodThreePrice, by="symbol")

# FINAL BACKTESTING PRICE DATAFRAME WITH NAMED COLUMNS
colnames(futurePrices) <- c("DMU","entryPrice", "oneYRprice", "threeYRprice", "fiveYRprice")

backtestingPrices <- merge(tempFuturePrices2, df_periodThreePrice, by="symbol")
colnames(backtestingPrices) <- c("DMU","entryPrice", "oneYRprice", "threeYRprice", "fiveYRprice")


#################
# GET SP500 DATA
#################

```

## Input-Output Diagram

```{r IOdiagram, eval=TRUE, echo=FALSE, out.width="100%", fig.align='center'}

# CREATE A VISUAL INPUT / OUTPUT DIAGRAM
XFigNames <- c("Debt to Equity", "Price to Book", "Beta", "Sigma")

YFigNames <- c("Earnings Per Share", "Return on Assets", "Return on Equity",
               "Net Profit Margin", "Trailing Rate of Return")

Figure <- DrawIOdiagram (XFigNames,YFigNames, '"\n\nUS Stock Market\nSector\n\n "')

tmp <- capture.output(rsvg_png(charToRaw (export_svg(Figure)), 
                               'IO-Stock-Diagram.png'))

knitr::include_graphics("IO-Stock-Diagram.png")

```


```{r CleanData, echo=FALSE, message=FALSE}

# CONVERT DATFRAME TO MATRIX FOR PROCESSING
converted_data <- data.matrix(df, rownames.force=NA)

# SLICE THE X AND Y VARIABLES FOR DEA
x <- data.matrix(converted_data[,2:5])  # ALL ROWS, COLS 2,3,4,5
y <- data.matrix(converted_data[,6:10]) # ALL ROWS, COLS 6,7,8,9,10

```

## 1, 2, 3 Month DEA Portfolio Performance Analysis

*Only 100% \index{efficient stocks} efficient stocks identified through DEA analysis are included
for the constructed portfolio.*

```{r GenerateCRS, echo=FALSE, message=FALSE}

#####################################################
# CONSTANT RETURNS TO SCALE MODEL
#####################################################

# SET THE LOOP COUNT AND DATA VARIABLE SIZES
NX <- ncol(x); NY <- ncol(y); ND <- nrow(x)
xdata <- x[1:ND,]
dim(xdata) <- c(ND, NX) 
ydata <- y[1:ND,]
dim(ydata) <- c(ND, NY)

# SETUP THE MODEL
results.efficiency <- matrix(rep(-1.0, 1), nrow=ND, ncol=1)
results.lambda     <- matrix(rep(-1.0, ND), nrow=ND,ncol=ND)

for (k in 1:ND) {

  results <- MIPModel()                                              |>
    add_variable(Vlambda[j], j = 1:ND, type = "continuous", lb = 0) |>
    add_variable(Vtheta, type = "continuous")                       |>
    set_objective(Vtheta, "min")                                    |>
    add_constraint(sum_expr(Vlambda[j] * xdata[j,i], j = 1:ND) 
                   <= Vtheta * xdata[k,i], i = 1:NX)                |>
    add_constraint(sum_expr(Vlambda[j] * ydata[j,r], j = 1:ND) 
                   >= ydata[k,r], r = 1:NY)                         |>
    solve_model(with_ROI(solver = "glpk")) 
  
#  print(c("DMU=",k,solver_status(results)))
  
  results.efficiency[k] <-  get_solution(results, Vtheta)       
  results.lambda[k,] <- t(as.matrix(as.numeric(
    get_solution(results, Vlambda[j])[,3] )))
}

temp_CRS <- cbind(DMUnames,
              results.efficiency)

colnames(temp_CRS) <- c("DMU","Efficiency Score")

temp_CRS_Basic_Materials <- temp_CRS

# SLICE OFF ONLY THE STOCKS THAT HAVE AN EFFICIENCY OF ONE (1)
only_efficient_stocks_CRS <- temp_CRS[temp_CRS[,2] >= 1.0,]

db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
#db_temp <- dbDisconnect(mydb) # CLOSE THE DATABASE CONNECTION, RESULTS IN TEMP

```

```{r CalculateReturnRates, echo=FALSE, message=FALSE}

# FUNCTION TO CALCULATE THE RATE OF RETURN BETWEEN TWO PRICES
rateOfReturn <- function(endPrice, startPrice){
    format(round(as.numeric(((as.numeric(endPrice) - as.numeric(startPrice)) / as.numeric(startPrice))*100), 2), nsmall=2)
}

# CALCULATE THE ONE YEAR RATE OF RETURN
oneYRreturnRate <- rateOfReturn(backtestingPrices$oneYRprice, backtestingPrices$entryPrice)

# CALCUALTE THE THREE YEAR RATE OF RETURN
threeYRreturnRate <- rateOfReturn(backtestingPrices$threeYRprice, backtestingPrices$entryPrice)

# CALCULATE THE FIVE YEAR RATE OF RETURN
fiveYRreturnRate <- rateOfReturn(backtestingPrices$fiveYRprice, backtestingPrices$entryPrice)

# BIND EACH CALCULATED RATE OF CHANGE AS COLUMNS
returnResults <- cbind(DMUnames, 
                       backtestingPrices$entryPrice,
                       backtestingPrices$oneYRprice, 
                       backtestingPrices$threeYRprice,
                       backtestingPrices$fiveYRprice,
                       oneYRreturnRate, 
                       threeYRreturnRate, 
                       fiveYRreturnRate)

# SET THE COLUMN NAMES OF THE RATE OF RETURN RESULTS
colnames(returnResults) <- c("DMU",
                             "entryPrice",
                             "oneYRprice",
                             "threeYRprice",
                             "fiveYRprice",
                             "OneYR",
                             "ThreeYR",
                             "FiveYR")

# MERGE THE EFFICIENT DMU DATAFRAME WITH THE RATE OF RETURN RESULT DATAFRAME
# NOTE: INNER JOIN BY DMU NAME
df_all = merge(x = only_efficient_stocks_CRS, y = returnResults, by = "DMU")

# CREATE THE CAPTION FOR THE REPORT USING THE SECTOR NAME SELECTED FOR STUDY
report_caption <- sprintf('%s Sector Portfolio Detail', toupper(SECTOR))

# OUTPUT THE DMU, EFFICENCY SCORE, AND RATE OF RETURNS
kbl(df_all, align = "lcrrrrrrr", booktabs=T, digits=3, escape=T, row.names=F,
    col.names=c("DMU", "Score", "Entry", "1 MO" ,"2 MO" ,"3 MO" , "1 MO", "2 MO", "3 MO"),
  caption= report_caption) |>
  add_header_above(c(" " = 1, "Efficiency" = 1, "Stock Prices ($)" = 4, "Holding Period Returns (%)" = 3))  |>
  kable_styling(latex_options = c("HOLD_position", "scale_down"))


############################################################################
# GET THE CROSS-EFFICIENCY SCORES FROM THE MULTIPLIERDEA LIBRARY FUNCTION
############################################################################
eff_result <- DeaMultiplierModel(xdata, ydata , "crs", "input")
cross_result <- CrossEfficiency(xdata, ydata, "crs", "input")
rownames(eff_result$Efficiency) <- DMUnames
###########################################################################

# CALCULATE NUMERICAL PRICE RETURNS
averageEntry <- format(sum(as.numeric(df_all$entryPrice)), digits=2, nsmall=2)
average1YRp <- format(sum(as.numeric(df_all$oneYRprice)), digits=2, nsmall=2)
average3YRp <- format(sum(as.numeric(df_all$threeYRprice)), digits=2, nsmall=2)
average5YRp <- format(sum(as.numeric(df_all$fiveYRprice)), digits=2, nsmall=2)

# CALCULATE THE ONE YEAR RATE OF RETURN
average1YR <- format((((as.numeric(average1YRp) - as.numeric(averageEntry)) 
               / as.numeric(averageEntry))*100), digits=2, nsmall=2)

# CALCUALTE THE THREE YEAR RATE OF RETURN
average3YR <- format((((as.numeric(average3YRp) - as.numeric(averageEntry)) 
               / as.numeric(averageEntry))*100), digits=2, nsmall=2)

# CALCULATE THE FIVE YEAR RATE OF RETURN
average5YR <- format((((as.numeric(average5YRp) - as.numeric(averageEntry)) 
               / as.numeric(averageEntry))*100), digits=2, nsmall=2)

# BUILD THE OUTPUT DATA
sector_average_text <- sprintf('%s', SECTOR)
sector_CRS_averages <- cbind(sector_average_text, 
                             averageEntry, average1YRp, average3YRp, average5YRp, 
                             average1YR, average3YR, average5YR)

# CREATE THE CAPTION FOR THE REPORT USING THE SECTOR NAME SELECTED FOR STUDY
report_caption <- sprintf('%s Sector Portfolio Summary', toupper(SECTOR))

kbl(sector_CRS_averages, align = "lrrrrrrr", booktabs=T, digits=3, escape=T, 
    row.names=F, longtable=F,
    col.names=c(" ", "Entry", "1 MO", "2 MO", "3 MO", "1 MO", "2 MO", "3 MO"),
    caption= report_caption) |>
  add_header_above(c(" " = 1, "Porfolio Value ($)" = 4, "Holding Period Returns (%)" = 3))  |>
  kable_styling(latex_options = c("HOLD_position", "scale_down"))

```

\newpage

## Graphs and Charts

```{r PriceGraphs, echo=FALSE, message=FALSE}

df2 <- data.frame(df_all)

df2$OneYR = as.numeric(as.character(df2$OneYR))

entry_price_val <- as.numeric(df_all$entryPrice)
exit_1YR_price_val <- as.numeric(df_all$oneYRprice)
exit_3YR_price_val <- as.numeric(df_all$threeYRprice)
exit_5YR_price_val <- as.numeric(df_all$fiveYRprice)

# GET THE CHART DATA
v <- sector_CRS_averages[,2:5]
t <- sector_CRS_averages[,6:8]

# CHART FILENAME
png(file = "line_chart_prices.png")

# PLOT THE CHART
plot(v, type = "o",col = "red", xlab = "Time", ylab = "Price", 
   main = "Portfolio Price Performance")
lines(t, type = "o", col = "blue")

# SAVE THE FILE
invisible(capture.output(dev.off()))

# INCLUDE THE FILE
knitr::include_graphics("line_chart_prices.png")
```

\newpage

```{r PercentReturnCharts, echo=FALSE, message=FALSE}

# GET THE CHART DATA
v <- sector_CRS_averages[,6:8]
t <- sector_CRS_averages[,2:5]

# CHART FILENAME
png(file = "line_chart_returns.png")

# PLOT THE CHART
plot(v, type = "o",col = "red", xlab = "Time", ylab = "Percent Return", 
   main = "Portfolio Returns Performance")
lines(t, type = "o", col = "blue")

# SAVE THE FILE
invisible(capture.output(dev.off()))

# INCLUDE THE FILE
knitr::include_graphics("line_chart_returns.png")

```

\newpage

## Data Source Examination

```{r ExploreData, echo=FALSE, message=FALSE}

# SET THE HEAD AND TAIL DIVIDERS
xdivider <- data.frame(DMU=c('---'), Beta=c('---'), Sigma=c('---'), DToE=c('---'), PToB=c('---'))
ydivider <- data.frame(DMU=c('---'), NetMrgn=c('---'), EPS=c('---'), ROA=c('---'), ROE=c('---'), TTMreturn=c('---'))

xx <- head(cbind(df['DMU'], x)) # SELECT THE FIRST FEW LINES FROM THE DATA
xxt <- tail(cbind(df['DMU'], x))
xxd <- rbind(xx,xdivider,xxt)

yy <- head(cbind(df['DMU'], y))
yyt <- tail(cbind(df['DMU'], y))
yyd <- rbind(yy,ydivider,yyt)

# SHOW THE INPUT VARIABLE EXAMPLES
kbl(xxd, booktabs=T, digits=3, escape=T, row.names=F, longtable=F,
    col.names=c("DMU","Beta", "Sigma", "Debt To Equity","Price to Book"),
    caption= 'Data Source Extract Example - INPUTS ($x$)')  |>
  kable_styling(latex_options = c("HOLD_position", "scale_down"))

# SHOW THE OUTPUT VARIABLE EXAMPLES
kbl(yyd, booktabs=T, digits=3, escape=T, row.names=F, longtable=F,
    col.names=c("DMU","Net Margin","EPS", "Return on Assets", "Return on Equity",
                "Rate of Return"),
    caption= 'Data Source Extract Example - OUTPUTS ($y$)')  |>
  kable_styling(latex_options = c("HOLD_position", "scale_down"))

```

\newpage

## Multiplier Model Analysis

```{r MultiplierModelResultVariables, echo=FALSE, message=FALSE}

mm1.efficiency <- matrix(rep(-1.0, ND), nrow=ND)
mm1.lambda     <- matrix(rep(-1.0, ND^2), nrow=ND)
mm1.vweight    <- matrix(rep(-1.0, ND*NX), nrow=ND) 
mm1.uweight    <- matrix(rep(-1.0, ND*NY), nrow=ND) 
mm1.xslack     <- matrix(rep(-1.0, ND*NX), nrow=ND) 
mm1.yslack     <- matrix(rep(-1.0, ND*NY), nrow=ND) 

mm1names <- TRA::DEAnames(NX, NY, ND)

xnames <- c("Beta $v_1$", "Sigma $v_2$", "DtoE $v_3$", "PtoB $v_4$")
ynames <- c("NetMgn $u_1$", "EPS $u_2$", "ROA $u_3$", "ROE $u_4$", "TM $u_5$")

```

```{r MuliplierModel, eval=TRUE, echo=FALSE, message=FALSE}

for (k in 1:ND) {

  result <- MIPModel() |>
  add_variable(vweight[i], i = 1:NX, type = "continuous", lb = 0)   |>
  add_variable(uweight[r], r = 1:NY, type = "continuous", lb = 0)   |>
  set_objective(sum_expr(uweight[r] * ydata[k,r], r = 1:NY), "max") |>
  add_constraint(sum_expr(vweight[i] * xdata[k,i], i = 1:NX) == 1)  |>
  add_constraint((sum_expr(uweight[r] * ydata[j,r], r = 1:NY)-
                    sum_expr(vweight[i] * xdata[j,i], i = 1:NX)) 
                 <= 0, j = 1:ND)
  result

  result <- solve_model(result, with_ROI(solver = "glpk", 
                                         verbose = FALSE))
  mm1.efficiency[k] <- objective_value (result) 

  # Get the output weights
  tempvweight <- get_solution(result, vweight[i])
  mm1.vweight[k,] <- tempvweight[,3]

  # Get the input weights
  tempuweight <- get_solution(result, uweight[i])
  mm1.uweight[k,] <- tempuweight[,3]
  templambda <- as.matrix(get_row_duals(result))
  mm1.lambda[k,] <- templambda [-1]
  # Drops the first dual value since that 
  #    constraint since is for setting denom=1
 }

mm1.input_wts  <- cbind(DMUnames,
                        format(mm1.efficiency, digits=2, nsmall=2),
                        format(mm1.vweight, digits=2, nsmall=2))
only_efficient_inputs <- mm1.input_wts[mm1.input_wts[,2] >= 1.0,]

mm1.output_wts <- cbind(DMUnames,
                        format(mm1.efficiency, digits=2, nsmall=2),
                        format(mm1.uweight, digits=2, nsmall=2))
only_efficient_outputs <- mm1.output_wts[mm1.output_wts[,2] >= 1.0,]

mm1.combined <- cbind (DMUnames,
                       format(mm1.efficiency, digits=2, nsmall=2), 
                       format(mm1.vweight, digits=2, nsmall=2), 
                       format(mm1.uweight, digits=2, nsmall=2))

mm1.combined_lambda <- cbind(DMUnames,
                       format(mm1.efficiency, digits=2, nsmall=2), 
                       format(mm1.lambda, digits=2, nsmall=2))

# SLICE OFF ONLY THE STOCKS THAT HAVE AN EFFICIENCY OF ONE (1)
only_efficient_stocks_MM <- mm1.combined[mm1.combined[,2] >= 1.0,]

efficient_MM <- only_efficient_stocks_MM[,3:11]
display_efficient_MM <- cbind(only_efficient_stocks_MM[,1], efficient_MM)

# TOO MANY LAMBDA VALUES TO VIEW IN A TYPICAL STOCK SECTOR DATA SET
#only_efficient_stocks_MM_labmda <- mm1.combined_lambda[mm1.combined_lambda[,2] >= 1.0,]

```

### Input/Output Weight Analysis

```{r MultiplierModelIOs, echo=FALSE, message=FALSE}

kbl (display_efficient_MM, booktabs=T, escape=F, digits=2, longtable=F,
     col.names=c("DMU", xnames, ynames),
     caption =c("Multiplier Model Results for Perfectly Efficient Stocks"))  |>
  add_header_above(c(" " = 1, "Inputs (x)" = 4, "Outputs (y)" = 5))  |>
  kable_styling (latex_options = c("HOLD_position", "scale_down"))

# kbl (only_efficient_stocks_MM_labmda, booktabs=T, escape=F, digits=2, longtable=F,
#      col.names=c("DMU", "$\\theta^{CRS}$", mm1names$LambdanamesbyletterLX),
#      caption =c("Multiplier Model Results"))  |>
#   kable_styling (latex_options = c("hold_position", "scale_down")) |>
#   landscape()

```

### Output Weight Analysis

```{r MultiplierModelOutputs, echo=FALSE, message=FALSE}

kbl (only_efficient_outputs, booktabs=T, escape=F, digits=2, longtable=F,
     col.names=c("DMU", "$\\theta^{CRS}$", ynames),
     caption =c("MM Output Weights for Perfectly Efficient Stocks"))  |>
  add_header_above(c(" " = 1, "Score" = 1, "Outputs (y)" = 5))  |>
  kable_styling (latex_options = c("HOLD_position", "scale_down"))

```

### Input Weight Analysis

```{r MultiplierModelInputs, echo=FALSE, message=FALSE}
kbl (only_efficient_inputs, booktabs=T, escape=F, digits=2, longtable=F,
     col.names=c("DMU", "$\\theta^{CRS}$", xnames),
     caption =c("MM Input Weights for Perfectly Efficient Stocks"))  |>
  add_header_above(c(" " = 1, "Score" = 1, "Inputs (x)" = 4))  |>
  kable_styling (latex_options = c("HOLD_position", "scale_down"))

```

\newpage

# Appendix

## Constant Returns to Scale Mathematical Model

$$
\begin{split}
\begin{aligned}
    \text{min  }   & \theta \\
    \text{s.t.:  } & \sum_{j=1}^{N^D} x_{i,j}\lambda_j - \theta x_{i,k} \leq 0 \; \forall \; i\\
                   & \sum_{j=1}^{N^D} y_{r,j}\lambda_j \geq  y_{r,k} \;  \forall \; r\\
                   & \lambda_j \geq 0  \; \forall \; j
  \end{aligned}
 \end{split}
$$

## Multiplier Mathematical Model

$$
\begin{split}
 \begin{aligned}
    \text {max   } & \sum_{r=1}^{N^Y} u_r y_{r,k} \\
    \text{s.t.:  } & \sum_{i=1}^{N^X} v_i x_{i,k} = 1 \\
    & \sum_{r=1}^{N^Y} u_r y_{r,j} - \sum_{i=1}^{N^X} v_i x_{i,j} 
                          \leq 0 \; \forall \; j\\
                   &  u_r, \; v_i\geq 0  \; \forall \; r,i
  \end{aligned}
 \end{split}
$$

\printindex
