---
title: "| Stock Portfolio Creation using Data Envelopment Analysis (DEA) \n| \n| ETM-506, Fall 2023\n| \n| Portland State University\n| \n| Professor: Dr. Timothy Anderson\n"
author: "Author: Duane A. Murray"
date: "`r format(Sys.time(), '%d %B, %Y')`"
header-includes:
  - \usepackage{float}
  - \usepackage{pdflscape}
  - \floatplacement{figure}{H}
output: 
  pdf_book: 
    toc: true 
    toc_depth: 5
  pdf_document: 
    toc: true 
    toc_depth: 5
editor_options: 
  markdown: 
    wrap: 72
---

\newpage

```{r, include=FALSE, eval=FALSE}

# RUN THIS CHUNK TO GENERATE A BOOKDOWN PDF DOC, OTHERWISE, KNIT TO PDF
knitr::opts_chunk$set(echo = TRUE)
library(tinytex)
library(bookdown)
library(rmarkdown)
library(kableExtra)
rmarkdown::render("ETM-506-DEA-Financial-Analysis-Murray.Rmd", "pdf_book")

```

```{r loadingPackages, include=FALSE, message=FALSE, warning=FALSE}
library(tinytex)
library(bookdown)
library(rmarkdown)

library(kableExtra, quietly=TRUE)
library(ROI, quietly=TRUE)             
library(ROI.plugin.glpk, quietly=TRUE) 
library(ompr, quietly=TRUE)            
library(ompr.roi, quietly=TRUE)
library(TRA, quietly=TRUE)
library(rsvg, quietly=TRUE)
library(DiagrammeR, quietly=TRUE)
library(DiagrammeRsvg, quietly=TRUE)
library(tidyverse, quietly=TRUE)
library(lessR, quietly=TRUE)
library(quantmod)
library(tidyquant)
library(dplyr)
library(plotly)
library(ggplot2, quietly=TRUE)
library(png)
library(grid)
library(RMySQL, quietly=TRUE)
library (MultiplierDEA, quietly=TRUE)

```


```{r configureParams, echo=FALSE, message=FALSE}

#####################################################################
# AVAILABLE SECTORS:
# NAME                    SZ      SYMBOL  AKA
# ----------------------- -----   ------  ---
# Basic Materials		      304     XLB     
# Communication Services	357     XTL     Telecommunications
# Consumer Cyclical	      673     XLY     Consumer Discretionary
# Consumer Defensive	    285     XLP     Consumer Staples
# Energy			            325     XLE
# Financial Services	    3415    XLF
# Healthcare		          1541    XLV
# Industrials		          926     XLI
# Real Estate		          503     XLRE
# Technology		          974     XLK     Information Technology
# Utilities		            146     XLU
######################################################################

SECTOR_NAME <- 'Technology'

###################################
# 1ST QUARTER
###################################
Q1_SECTOR <- SECTOR_NAME
Q1_FiscalYear <- '2017'
Q1_Quarter <- 'Q1'
Q1_FirstDayQuarter <- '2017-01-03'
Q1_MonthName <- 'March'  # LAST MO OF QTR

Q1_StartDate <- '2017-03-01'
Q1_EndDate <- '2017-03-31'

Q1_periodOneDate <- '2017-04-28'
Q1_periodTwoDate <- '2017-05-31'
Q1_periodThreeDate <- '2017-06-30'
###################################

###################################
# 2ND QUARTER
###################################
Q2_SECTOR <- SECTOR_NAME
Q2_FiscalYear <- '2017'
Q2_Quarter <- 'Q2'
Q2_FirstDayQuarter <- '2017-04-03'
Q2_MonthName <- 'June'  # LAST MO OF QTR
#
Q2_StartDate <- '2017-06-01'
Q2_EndDate <- '2017-06-30'
#
Q2_periodOneDate <- '2017-07-31'
Q2_periodTwoDate <- '2017-08-31'
Q2_periodThreeDate <- '2017-09-29'
###################################

###################################
# 3RD QUARTER
###################################
Q3_SECTOR <- SECTOR_NAME
Q3_FiscalYear <- '2017'
Q3_Quarter <- 'Q3'
Q3_FirstDayQuarter <- '2017-07-03'
Q3_MonthName <- 'September' # LAST MO OF QTR
#
Q3_StartDate <- '2017-09-01'
Q3_EndDate <- '2017-09-29'
#
Q3_periodOneDate <- '2017-10-31'
Q3_periodTwoDate <- '2017-11-30'
Q3_periodThreeDate <- '2017-12-29'
###################################

###################################
# 4TH QUARTER
###################################
Q4_SECTOR <- SECTOR_NAME
Q4_FiscalYear <- '2017'
Q4_Quarter <- 'Q4'
Q4_FirstDayQuarter <- '2017-10-02'
Q4_MonthName <- 'December'  # LAST MO OF QTR
#
Q4_StartDate <- '2017-12-01'
Q4_EndDate <- '2017-12-29'
#
Q4_periodOneDate <- '2018-01-31'
Q4_periodTwoDate <- '2018-02-28'
Q4_periodThreeDate <- '2018-03-29'
###################################

```


```{r LoadDataMySQL, echo=FALSE, message=FALSE}

# CONNECT TO MYSQL DATABASE
mydb = dbConnect(MySQL(), 
                 user='vsc', 
                 password='blaster123', 
                 dbname='stockdata', 
                 host='127.0.0.1')

########################################################################
# Q1 - QUERY ALL STOCK DEA INPUTS AND OUTPUTS, AND 1,3,6 MONTH FUTURE PRICES
########################################################################
Q1_sql_select <- sprintf("
SELECT 
	b.symbol AS 'DMU', 
	b.beta AS 'Beta', 
	b.sigma AS 'Sigma', 
	r.debtEquityRatio AS 'DToE', 
	r.priceToBookRatio AS 'PToB', 
	r.netProfitMargin AS 'NetMrgn',
  e.netIncomePerShare as 'EPS',
	r.returnOnAssets AS 'ROA', 
	r.returnOnEquity as 'ROE',
	b.StockReturnRate as 'TTMreturn',
  p.Close AS 'entryPrice',
  p.Close AS 'periodOnePrice',
  p.Close AS 'periodTwoPrice',
  p.Close AS 'periodThreePrice',
  b.Sector AS 'Sector'
FROM 
	stockdata.company_beta_sigma b, 
	stockdata.company_ratios r,
  stockdata.company_eps_pe e,
  stockdata.equity_prices p
WHERE 
	b.Sector = '%s'
  AND monthname(b.StartDate) = '%s'
	AND b.Year = '%s'
	AND b.Quarter = '%s'
	AND r.calendarYear = '%s'
	AND r.Period = '%s'
  AND e.calendarYear = '%s'
  AND e.period = '%s'
	AND b.Symbol = r.Symbol
	AND p.Symbol = b.Symbol
  AND e.Symbol = b.Symbol
  AND b.beta != 0
	AND b.sigma != 0 
	AND r.debtEquityRatio != 0
	AND r.priceToBookRatio != 0
	AND r.netProfitMargin != 0
	AND e.netIncomePerShare != 0
	AND r.returnOnAssets != 0 
	AND r.returnOnEquity != 0
	AND b.StockReturnRate != 0
	AND p.Close != 0
  AND p.date = b.EndDate", 
Q1_SECTOR, Q1_MonthName, Q1_FiscalYear, Q1_Quarter, Q1_FiscalYear, Q1_Quarter,  Q1_FiscalYear, Q1_Quarter);

# RUN THE QUERY AND GET THE RESULTS
rs = dbSendQuery(mydb, Q1_sql_select)
df_Q1 = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS

Q1_number_of_source_records <- nrow(df_Q1)

db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

# SET THE DMU NAMES
Q1_DMUnames <- df_Q1[,1] # ALL ROWS, COL 1

Q1_df_periodOnePrice <- data.frame()
Q1_df_periodTwoPrice <- data.frame()
Q1_df_periodThreePrice <- data.frame()

##########################################
# GET FUTURE PRICE DATA FOR BACKTESTING
##########################################
for (stock_symbol in Q1_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", 
  stock_symbol, Q1_periodOneDate);

  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q1_df_periodOnePrice <- rbind(Q1_df_periodOnePrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

for (stock_symbol in Q1_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", 
  stock_symbol, Q1_periodTwoDate);

  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q1_df_periodTwoPrice <- rbind(Q1_df_periodTwoPrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

for (stock_symbol in Q1_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", 
  stock_symbol, Q1_periodThreeDate);

  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q1_df_periodThreePrice <- rbind(Q1_df_periodThreePrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

# BUILD THE BACKTESTING DATAFRAME FROM THE FUTURE PRICES
tempDataframe <- cbind(df_Q1[,1], df_Q1[,11])  # DMU AND ENTRY PRICE
colnames(tempDataframe) <- c("symbol","entry")
tempFuturePrices1 <- merge(tempDataframe, Q1_df_periodOnePrice, by="symbol")
tempFuturePrices2 <- merge(tempFuturePrices1, Q1_df_periodTwoPrice, by="symbol")
futurePrices <- merge(tempFuturePrices2, Q1_df_periodThreePrice, by="symbol")

# FINAL BACKTESTING PRICE DATAFRAME WITH NAMED COLUMNS
colnames(futurePrices) <- c("DMU","entryPrice", "periodOnePrice", "periodTwoPrice", "periodThreePrice")

Q1_backtestingPrices <- merge(tempFuturePrices2, Q1_df_periodThreePrice, by="symbol")
colnames(Q1_backtestingPrices) <- c("DMU","entryPrice", "periodOnePrice", "periodTwoPrice", "periodThreePrice")


####################
# Q1 GET SP500 DATA
####################
sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", 
"^GSPC", Q1_EndDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q1_df_sp500_periodStart = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", 
"^GSPC", Q1_periodOneDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q1_df_sp500_periodOne = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", 
"^GSPC", Q1_periodTwoDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q1_df_sp500_periodTwo = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", 
"^GSPC", Q1_periodThreeDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q1_df_sp500_periodThree = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

Q1_sp500_allPeriods <- cbind(Q1_df_sp500_periodStart, Q1_df_sp500_periodOne, Q1_df_sp500_periodTwo, Q1_df_sp500_periodThree)
colnames(Q1_sp500_allPeriods) <- c("Entry", "SP500periodOne", "SP500periodTwo", "SP500periodThree")



########################################################################
# Q2 - QUERY ALL STOCK DEA INPUTS AND OUTPUTS, AND 1,3,6 MONTH FUTURE PRICES
########################################################################
Q2_sql_select <- sprintf("
SELECT 
	b.symbol AS 'DMU', 
	b.beta AS 'Beta', 
	b.sigma AS 'Sigma', 
	r.debtEquityRatio AS 'DToE', 
	r.priceToBookRatio AS 'PToB', 
	r.netProfitMargin AS 'NetMrgn',
  e.netIncomePerShare as 'EPS',
	r.returnOnAssets AS 'ROA', 
	r.returnOnEquity as 'ROE',
	b.StockReturnRate as 'TTMreturn',
  p.Close AS 'entryPrice',
  p.Close AS 'periodOnePrice',
  p.Close AS 'periodTwoPrice',
  p.Close AS 'periodThreePrice',
  b.Sector AS 'Sector'
FROM 
	stockdata.company_beta_sigma b, 
	stockdata.company_ratios r,
  stockdata.company_eps_pe e,
  stockdata.equity_prices p
WHERE 
	b.Sector = '%s'
  AND monthname(b.StartDate) = '%s'
	AND b.Year = '%s'
	AND b.Quarter = '%s'
	AND r.calendarYear = '%s'
	AND r.Period = '%s'
  AND e.calendarYear = '%s'
  AND e.period = '%s'
	AND b.Symbol = r.Symbol
	AND p.Symbol = b.Symbol
  AND e.Symbol = b.Symbol
  AND b.beta != 0
	AND b.sigma != 0 
	AND r.debtEquityRatio != 0
	AND r.priceToBookRatio != 0
	AND r.netProfitMargin != 0
	AND e.netIncomePerShare != 0
	AND r.returnOnAssets != 0 
	AND r.returnOnEquity != 0
	AND b.StockReturnRate != 0
	AND p.Close != 0
  AND p.date = b.EndDate", 
Q2_SECTOR, Q2_MonthName, Q2_FiscalYear, Q2_Quarter, Q2_FiscalYear, Q2_Quarter,  Q2_FiscalYear, Q2_Quarter);

# RUN THE QUERY AND GET THE RESULTS
rs = dbSendQuery(mydb, Q2_sql_select)
df_Q2 = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS

Q2_number_of_source_records <- nrow(df_Q2)

db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

# SET THE DMU NAMES
Q2_DMUnames <- df_Q2[,1] # ALL ROWS, COL 1

Q2_df_periodOnePrice <- data.frame()
Q2_df_periodTwoPrice <- data.frame()
Q2_df_periodThreePrice <- data.frame()

##########################################
# GET FUTURE PRICE DATA FOR BACKTESTING
##########################################
for (stock_symbol in Q2_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", 
  stock_symbol, Q2_periodOneDate);

  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q2_df_periodOnePrice <- rbind(Q2_df_periodOnePrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

for (stock_symbol in Q2_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", 
  stock_symbol, Q2_periodTwoDate);

  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q2_df_periodTwoPrice <- rbind(Q2_df_periodTwoPrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

for (stock_symbol in Q2_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", 
  stock_symbol, Q2_periodThreeDate);

  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q2_df_periodThreePrice <- rbind(Q2_df_periodThreePrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

# BUILD THE BACKTESTING DATAFRAME FROM THE FUTURE PRICES
tempDataframe <- cbind(df_Q2[,1], df_Q2[,11])  # DMU AND ENTRY PRICE
colnames(tempDataframe) <- c("symbol","entry")
tempFuturePrices1 <- merge(tempDataframe, Q2_df_periodOnePrice, by="symbol")
tempFuturePrices2 <- merge(tempFuturePrices1, Q2_df_periodTwoPrice, by="symbol")
futurePrices <- merge(tempFuturePrices2, Q2_df_periodThreePrice, by="symbol")

# FINAL BACKTESTING PRICE DATAFRAME WITH NAMED COLUMNS
colnames(futurePrices) <- c("DMU","entryPrice", "periodOnePrice", "periodTwoPrice", "periodThreePrice")

Q2_backtestingPrices <- merge(tempFuturePrices2, Q2_df_periodThreePrice, by="symbol")
colnames(Q2_backtestingPrices) <- c("DMU","entryPrice", "periodOnePrice", "periodTwoPrice", "periodThreePrice")


####################
# Q2 GET SP500 DATA
####################
sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", 
"^GSPC", Q2_EndDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q2_df_sp500_periodStart = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", 
"^GSPC", Q2_periodOneDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q2_df_sp500_periodOne = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", 
"^GSPC", Q2_periodTwoDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q2_df_sp500_periodTwo = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", 
"^GSPC", Q2_periodThreeDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q2_df_sp500_periodThree = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

Q2_sp500_allPeriods <- cbind(Q2_df_sp500_periodStart, Q2_df_sp500_periodOne, Q2_df_sp500_periodTwo, Q2_df_sp500_periodThree)
colnames(Q2_sp500_allPeriods) <- c("Entry", "SP500periodOne", "SP500periodTwo", "SP500periodThree")



########################################################################
# Q3 - QUERY ALL STOCK DEA INPUTS AND OUTPUTS, AND 1,3,6 MONTH FUTURE PRICES
########################################################################
Q3_sql_select <- sprintf("
SELECT 
	b.symbol AS 'DMU', 
	b.beta AS 'Beta', 
	b.sigma AS 'Sigma', 
	r.debtEquityRatio AS 'DToE', 
	r.priceToBookRatio AS 'PToB', 
	r.netProfitMargin AS 'NetMrgn',
  e.netIncomePerShare as 'EPS',
	r.returnOnAssets AS 'ROA', 
	r.returnOnEquity as 'ROE',
	b.StockReturnRate as 'TTMreturn',
  p.Close AS 'entryPrice',
  p.Close AS 'periodOnePrice',
  p.Close AS 'periodTwoPrice',
  p.Close AS 'periodThreePrice',
  b.Sector AS 'Sector'
FROM 
	stockdata.company_beta_sigma b, 
	stockdata.company_ratios r,
  stockdata.company_eps_pe e,
  stockdata.equity_prices p
WHERE 
	b.Sector = '%s'
  AND monthname(b.StartDate) = '%s'
	AND b.Year = '%s'
	AND b.Quarter = '%s'
	AND r.calendarYear = '%s'
	AND r.Period = '%s'
  AND e.calendarYear = '%s'
  AND e.period = '%s'
	AND b.Symbol = r.Symbol
	AND p.Symbol = b.Symbol
  AND e.Symbol = b.Symbol
  AND b.beta != 0
	AND b.sigma != 0 
	AND r.debtEquityRatio != 0
	AND r.priceToBookRatio != 0
	AND r.netProfitMargin != 0
	AND e.netIncomePerShare != 0
	AND r.returnOnAssets != 0 
	AND r.returnOnEquity != 0
	AND b.StockReturnRate != 0
	AND p.Close != 0
  AND p.date = b.EndDate", 
Q3_SECTOR, Q3_MonthName, Q3_FiscalYear, Q3_Quarter, Q3_FiscalYear, Q3_Quarter,  Q3_FiscalYear, Q3_Quarter);

# RUN THE QUERY AND GET THE RESULTS
rs = dbSendQuery(mydb, Q3_sql_select)
df_Q3 = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS

Q3_number_of_source_records <- nrow(df_Q3)

db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

# SET THE DMU NAMES
Q3_DMUnames <- df_Q3[,1] # ALL ROWS, COL 1

Q3_df_periodOnePrice <- data.frame()
Q3_df_periodTwoPrice <- data.frame()
Q3_df_periodThreePrice <- data.frame()

##########################################
# GET FUTURE PRICE DATA FOR BACKTESTING
##########################################
for (stock_symbol in Q3_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", stock_symbol, Q3_periodOneDate);
  
  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q3_df_periodOnePrice <- rbind(Q3_df_periodOnePrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

for (stock_symbol in Q3_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", stock_symbol, Q3_periodTwoDate);
  
  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q3_df_periodTwoPrice <- rbind(Q3_df_periodTwoPrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

for (stock_symbol in Q3_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", stock_symbol, Q3_periodThreeDate);
  
  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q3_df_periodThreePrice <- rbind(Q3_df_periodThreePrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

# BUILD THE BACKTESTING DATAFRAME FROM THE FUTURE PRICES
tempDataframe <- cbind(df_Q3[,1], df_Q3[,11])  # DMU AND ENTRY PRICE
colnames(tempDataframe) <- c("symbol","entry")
tempFuturePrices1 <- merge(tempDataframe, Q3_df_periodOnePrice, by="symbol")
tempFuturePrices2 <- merge(tempFuturePrices1, Q3_df_periodTwoPrice, by="symbol")
futurePrices <- merge(tempFuturePrices2, Q3_df_periodThreePrice, by="symbol")

# FINAL BACKTESTING PRICE DATAFRAME WITH NAMED COLUMNS
colnames(futurePrices) <- c("DMU","entryPrice", "periodOnePrice", "periodTwoPrice", "periodThreePrice")

Q3_backtestingPrices <- merge(tempFuturePrices2, Q3_df_periodThreePrice, by="symbol")
colnames(Q3_backtestingPrices) <- c("DMU","entryPrice", "periodOnePrice", "periodTwoPrice", "periodThreePrice")

#####################
# Q3 GET SP500 DATA
#####################
sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", "^GSPC", Q3_EndDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q3_df_sp500_periodStart = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", "^GSPC", Q3_periodOneDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q3_df_sp500_periodOne = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", "^GSPC", Q3_periodTwoDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q3_df_sp500_periodTwo = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", "^GSPC", Q3_periodThreeDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q3_df_sp500_periodThree = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

Q3_sp500_allPeriods <- cbind(Q3_df_sp500_periodStart, Q3_df_sp500_periodOne, Q3_df_sp500_periodTwo, Q3_df_sp500_periodThree)
colnames(Q3_sp500_allPeriods) <- c("Entry", "SP500periodOne", "SP500periodTwo", "SP500periodThree")


########################################################################
# Q4 - QUERY ALL STOCK DEA INPUTS AND OUTPUTS, AND 1,3,6 MONTH FUTURE PRICES
########################################################################
Q4_sql_select <- sprintf("
SELECT 
	b.symbol AS 'DMU', 
	b.beta AS 'Beta', 
	b.sigma AS 'Sigma', 
	r.debtEquityRatio AS 'DToE', 
	r.priceToBookRatio AS 'PToB', 
	r.netProfitMargin AS 'NetMrgn',
  e.netIncomePerShare as 'EPS',
	r.returnOnAssets AS 'ROA', 
	r.returnOnEquity as 'ROE',
	b.StockReturnRate as 'TTMreturn',
  p.Close AS 'entryPrice',
  p.Close AS 'periodOnePrice',
  p.Close AS 'periodTwoPrice',
  p.Close AS 'periodThreePrice',
  b.Sector AS 'Sector'
FROM 
	stockdata.company_beta_sigma b, 
	stockdata.company_ratios r,
  stockdata.company_eps_pe e,
  stockdata.equity_prices p
WHERE 
	b.Sector = '%s'
  AND monthname(b.StartDate) = '%s'
	AND b.Year = '%s'
	AND b.Quarter = '%s'
	AND r.calendarYear = '%s'
	AND r.Period = '%s'
  AND e.calendarYear = '%s'
  AND e.period = '%s'
	AND b.Symbol = r.Symbol
	AND p.Symbol = b.Symbol
  AND e.Symbol = b.Symbol
  AND b.beta != 0
	AND b.sigma != 0 
	AND r.debtEquityRatio != 0
	AND r.priceToBookRatio != 0
	AND r.netProfitMargin != 0
	AND e.netIncomePerShare != 0
	AND r.returnOnAssets != 0 
	AND r.returnOnEquity != 0
	AND b.StockReturnRate != 0
	AND p.Close != 0
  AND p.date = b.EndDate", 
Q4_SECTOR, Q4_MonthName, Q4_FiscalYear, Q4_Quarter, Q4_FiscalYear, Q4_Quarter,  Q4_FiscalYear, Q4_Quarter);

# RUN THE QUERY AND GET THE RESULTS
rs = dbSendQuery(mydb, Q4_sql_select)
df_Q4 = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS

Q4_number_of_source_records <- nrow(df_Q4)

db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

# SET THE DMU NAMES
Q4_DMUnames <- df_Q4[,1] # ALL ROWS, COL 1

Q4_df_periodOnePrice <- data.frame()
Q4_df_periodTwoPrice <- data.frame()
Q4_df_periodThreePrice <- data.frame()

##########################################
# GET FUTURE PRICE DATA FOR BACKTESTING
##########################################
for (stock_symbol in Q4_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", stock_symbol, Q4_periodOneDate);
  
  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q4_df_periodOnePrice <- rbind(Q4_df_periodOnePrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

for (stock_symbol in Q4_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", stock_symbol, Q4_periodTwoDate);
  
  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q4_df_periodTwoPrice <- rbind(Q4_df_periodTwoPrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

for (stock_symbol in Q4_DMUnames) {
  
  sql_select <- sprintf("
  SELECT symbol, close FROM equity_prices
  WHERE symbol = '%s'
  AND date = '%s'", stock_symbol, Q4_periodThreeDate);
  
  rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
  df_temp = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
  
  Q4_df_periodThreePrice <- rbind(Q4_df_periodThreePrice, df_temp)
  
  db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR
}

# BUILD THE BACKTESTING DATAFRAME FROM THE FUTURE PRICES
tempDataframe <- cbind(df_Q4[,1], df_Q4[,11])  # DMU AND ENTRY PRICE
colnames(tempDataframe) <- c("symbol","entry")
tempFuturePrices1 <- merge(tempDataframe, Q4_df_periodOnePrice, by="symbol")
tempFuturePrices2 <- merge(tempFuturePrices1, Q4_df_periodTwoPrice, by="symbol")
futurePrices <- merge(tempFuturePrices2, Q4_df_periodThreePrice, by="symbol")

# FINAL BACKTESTING PRICE DATAFRAME WITH NAMED COLUMNS
colnames(futurePrices) <- c("DMU","entryPrice", "periodOnePrice", "periodTwoPrice", "periodThreePrice")

Q4_backtestingPrices <- merge(tempFuturePrices2, Q4_df_periodThreePrice, by="symbol")
colnames(Q4_backtestingPrices) <- c("DMU","entryPrice", "periodOnePrice", "periodTwoPrice", "periodThreePrice")

#####################
# Q4 GET SP500 DATA
#####################
sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", "^GSPC", Q4_EndDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q4_df_sp500_periodStart = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", "^GSPC", Q4_periodOneDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q4_df_sp500_periodOne = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", "^GSPC", Q4_periodTwoDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q4_df_sp500_periodTwo = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

sql_select <- sprintf("
SELECT close FROM market_index
WHERE symbol = '%s'
AND date = '%s'", "^GSPC", Q4_periodThreeDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q4_df_sp500_periodThree = fetch(rs, n=-1) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

Q4_sp500_allPeriods <- cbind(Q4_df_sp500_periodStart, Q4_df_sp500_periodOne, Q4_df_sp500_periodTwo, Q4_df_sp500_periodThree)
colnames(Q4_sp500_allPeriods) <- c("Entry", "SP500periodOne", "SP500periodTwo", "SP500periodThree")

#################
# ZERO RISK RATE
#################
current_bank_rates = 5.25 # AVERAGE CURRENT APY
monthly_bank_rates = (current_bank_rates / 12)  # MONTHLY RETURN RATE %

```

# Introduction

Investing in the stock market is common among firms, individuals, and
other entities as a method to increase the value of their retained
holdings. Several risks exist with this form of investing due to the
outside actions of other stock traders, news events, and unforeseen
shocks that occur within the economy. Thousands of stocks are available
to trade in the United States markets which are divided primarily into
the New York Stock Exchange (NYSE), and the National Association of
Securities Dealers Automated Quotations (NASDAQ) [1]. In
addition, several market indices track specific portfolios of stocks,
such as the Dow Jones Industrial Average (DJI), and the S&P 500 Index
(SPX). Further, many stocks are binned into Sectors, such as Technology,
Telecommunications, and others, which are then broken deeper into
Industry classifications that include Hardware, Software, and many
others [1]. Given the voluminous size of the stock market, and the outside
influences that create price movements, it is a significant challenge to
pick profitable stocks.

This study extends prior works using Data Envelopment Analysis (DEA) as a tool to help
evaluate groups of stocks to find which may be the most efficient in
regard to how they perform in the market. DEA uses linear programming
(LP), and can use large numbers of decision making units (DMUs) to
perform a comparative analysis of units in a data set by computing the
relative efficiency for each DMU. Using this analysis, a DMU with a
value of one (1) is considered 100% efficient in relation to the other
DMUs within the set [2]. 

This study focuses solely on the `r Q1_SECTOR` sector to find 100% efficient stocks 
to combine in creating a portfolio that outperforms risk-free savings rates
and the S&P 500 market index returns.

Differing time frames are used by stock traders depending on the risk
tolerance of the investor. This includes day trading, swing trading, and
long-term investing [3]. This study focuses on the short-term, using the
quarterly financial reporting ratios combined with one month market price
movement ratios. 1-month, 2-month, and 3-month investment windows are used for 
back-testing analysis. The DEA model uses both technical and fundamental indicators 
as the input and output variables. Technical indicators are values that are
derived solely by the price and volume changes in the market, and
fundamental indicators are derived from the underlying firms publicly
filed financial statements [4]. From a technical analysis perspective, there
is an assumption that news events, and outside effects are all baked
into the current price of a stock in the short-term. Further, it considers that history
tends to repeat itself, so past price movements are used to predict
future prices. From the fundamental analysis side, the financial health
of the underlying firm is an important factor to consider. There are
several quaterly financial ratios used to assess how a firm is operating. For
example, these ratios can provide insight into how profitable the firm
may be, including how much debt it is carrying, how much inventory it
holds, and how it handles its retained earnings, which are all taken
into consideration of the investment decision [5].

It has been shown in several other studies that using a mixture of
technical and fundamental variables within a DEA model can produce an
effective positive return stock portfolio. This study uses variables
defined within prior studies using a technical/fundamental variable mixture [6].
Back testing is completed in this study to verify the effectiveness of
using this DEA method to build an efficient stock portfolio. This
testing is performed using historical data by measuring the rate of
change that each stock experienced over 1, 2, and 3 month time periods
after its initial investment date [7]. An analysis of the average rate of
return for the portfolio is then compared to the rate of return provided
by the risk-free savings rate and the S&P 500 over the same time periods. 
The S&P 500 return rates define the minimum acceptable rate of return (MARR) 
for analysis. This assessment is used to determine if the portfolio outperformed, 
matched, or under performed the market benchmark [8]. In any case, achieving a
positive rate higher than the risk-free savings rate is an acceptable return.

This study begins by discussing some of the prior research that has been done in
using DEA for stock analysis, then sets to define and describe the model and
data set, including the input and output variables used in the model. Using the 
efficiency results from this approach, back-testing is then done to assess the 
rate of return results outcomes for comparison to the average market returns, 
which is then followed by concluding remarks.

# Literature Review

Using DEA to select stocks through the analysis of their respective relative 
efficiency scores has been done in prior research studies. In DEA terms, each
stock in the data set is treated as a unique decision making unit (DMU) where
comparisons are made to determine which DMUs are the most efficient. Methods
can be used in DEA to identify areas of improvement in non-efficient units to
potentially increase efficiency to meet those that are on the efficiency
frontier [2].

This study focuses on building a portfolio of stocks sourced from the 
`r Q1_SECTOR` sector using the methodology of prior work, where source variables
come from a mixture of technical and fundamental stock indicators [4, 6]. Prior 
studies have shown that using only technical or only fundamental indicators to
build an efficient stock portfolio do not perform as well as using a mixture of
each [6].

An examination of the use of a mixture of various momentum-based and fundamental 
financial based stock indicators shows that [9]:

- The future performance of stock returns is positively related to a firms
financial condition.
- Past returns suggest future return rates.
- The statistical correlation between technical and fundamental variables are low.
- Combining past returns, momentum indicators, and fundamentals generates better 
performance in regard to return rates than momentum or fundamental indicators alone.

The selection of specific performance metrics to evaluate a firms efficiency is
paramount to making an investment decision. In building a stock portfolio, it has
been found that only using 100% efficient stocks provide the best returns than
those that rate in ranges, such as 80% or above. In addition, it has been found
that the size of a firm is not a predictor of future stock value. Further, 
DEA input-oriented models have shown to provide better results than output-oriented
models, and these model both statistically outperform the industry averages [10].

Using the each firms Debt to Equity, and Price to Book ratios, together with the
standard deviation and beta momentum technical indicators as DEA model inputs 
combined with each Net Profit Margin, Rate of Return, Earnings Per Share, 
Return on Assets, and Return on Equity ratio as outputs, has shown to be 
effective in producing a high performance stock portfolio [9].

# Data and Methodology

The data set used in this study was sourced from the `r Q1_SECTOR`
Sector of stocks traded in the United States for the year of 2017.
The initial data set contained 1654 unique stocks. This set of data was
then cleaned by:

-   Removal of stocks that did not contain a full years worth of data.
-   Removal of stocks that did not contain numeric values to effectively
    calculate all input and output variables.

The end results contained a range of 422-466 unique stocks with complete data for
analysis. The range is due to differing numbers by quarter of available stock data for each
analysis time period. 

Technical stock indicators used are the Beta ($\beta$) [11], Sigma
($\sigma$) [12], and 1-Month Return Rate values. These indicators provide
insight into how well the stock moves in relation to the overall market,
how much the range of the closing price fluctuates over time, and the
annual return rate.

Fundamental stock values come from each firms Profit & Loss, and Balance
Sheet financial statements as provided in their Security and Exchange
Commission (SEC) 10-K filings. These values come from the reported
income and reports for each quarter of 2017. These "fundamentals" are Debt to 
Equity, Price to Book, Earnings per Share, Return on Assets, Return on Equity, 
and the Net Profit Margin [4].

Back-testing of the resulting lists of efficient stocks to measure
outcome results is completed by using the first trading day after the end of
each financial quarter as the initial investment starting date for each 
quarterly generated portfolio [7]. Measurement of the rate of return provided by
each stock using historical data from this starting date is used to
assess later time frames. An assessment of the performance of the DEA
generated stock portfolio is done using the 1-Month, 2-Month, and
3-Month return rates, compared to the 1-Month, 2-Month, and 3-Month
return rates of the S&P 500 market index. A portfolio return rate that
is greater than the S&P 500 return rate is considered to be
outperforming the market; less than the S&P 500 return rate would be
under performing the market [8]. A portfolio return rate higher than the 
risk-free savings rate is also considered a positive result.

## Input Oriented Mathematical Model

DEA Multiplier Model

$$
\begin{split}
 \begin{aligned}
    \text {max   } & \sum_{r=1}^{N^Y} u_r y_{r,k} \\
    \text{s.t.:  } & \sum_{i=1}^{N^X} v_i x_{i,k} = 1 \\
    & \sum_{r=1}^{N^Y} u_r y_{r,j} - \sum_{i=1}^{N^X} v_i x_{i,j} 
                          \leq 0 \; \forall \; j\\
                   &  u_r, \; v_i\geq 0  \; \forall \; r,i
  \end{aligned}
 \end{split}
$$
\newpage

## Input-Output Diagram

4 input ($x$), 5 output ($y$) model:


```{r IOdiagram, eval=TRUE, echo=FALSE, out.width="100%", fig.align='center'}

# CREATE A VISUAL INPUT / OUTPUT DIAGRAM
XFigNames <- c("Debt to Equity", "Price to Book", "Beta", "Sigma")

YFigNames <- c("Earnings Per Share", "Return on Assets", "Return on Equity",
               "Net Profit Margin", "Trailing Rate of Return")

Figure <- DrawIOdiagram (XFigNames,YFigNames, '"\n\nUS Stock Market\nSector\n\n "')

tmp <- capture.output(rsvg_png(charToRaw (export_svg(Figure)), 
                               'IO-Stock-Diagram.png'))
 
```

```{r GetIODiagram, fig.width=4.8, fig.height=2.7, echo=FALSE}

#knitr::include_graphics("IO-Stock-Diagram.png")

img <- readPNG("IO-Stock-Diagram.png")
 grid.raster(img)
 
```

## Inputs

\vspace{12pt}

### Beta ($\beta$)

The Beta ($\beta$) value indicates how volatile the price of a stock is
when compared to the overall stock market. The S&P 500 market index is
commonly used for this calculation, and is used in this study for this
purpose. A Beta value greater than one (1) is an indication that the
price of the stock moves higher than the comparison market index. A Beta value 
that is less than one (1) indicates that the price of the stock moves less than 
the comparison index. A negative Beta indicates that the stock moves in the
opposite direction of the comparison market index [11].

$$
\begin{aligned}
\beta_a = \frac { \text{Cov} ( r_a, r_b ) }{ \text{Var} ( r_b ) } \\ 
\end{aligned}
$$ 

This value can also be calculated using a linear regression method
where the stock price values are the dependent variable values, and the
reference index value, the S&P 500 in this study, as the independent
variable values. The coefficient of the result is the Beta value (the
slope).

### Sigma ($\sigma$)

The Sigma ($\sigma$) value is another measurement of volatility that
shows how far prices move above or below the mean. It is a measurement
of the spread that a stock price moves around its average price. A high
standard deviation means that there is high volatility, where a smaller
standard deviation, or spread in prices indicates low volatility [12].

$$
\begin{aligned}
\sigma = \sqrt{\frac{1}{N} \sum_{i=1}^{N} (x_i - \mu)^2}
\end{aligned}
$$

\vspace{12pt}

### Debt to Equity Ratio

\vspace{12pt}

This is the ratio of firm's Total Liabilities to Equity Capital. A high
Debt to Equity Ratio indicates a higher risk to investors. A low Debt to
Equity indicates a lower risk to investors [13].

$$
\begin{split}
 \begin{aligned}
\text{Debt to Equity Ratio} & = \frac{\text{Total Debt}} {\text{Total Equity}}
  \end{aligned}
\end{split}
$$

### Price to Book Ratio

\vspace{12pt}

From an investment perspective, the Price to Book Ratio is used for
comparison of a firms market capitalization to its book value. It is
derived through dividing the firms current stock price by its book value
per share. This ratio indicates how well the stock is priced related to
the book value of the firm. A Price to Book ratio under one (1)
indicates that the price of the stock is lower than the value of the
firm, suggesting that the stock is under priced. A lower Price to Book
is better than a higher Price to Book ratio when considering an
investment [14].

$$
\begin{split}
 \begin{aligned}
\text{Price to Book Ratio} & = \frac{\text{Current Stock Price Per Share}} {\text{Book Value Per Share}}
  \end{aligned}
\end{split}
$$

## Outputs

\vspace{12pt}

### Earnings per Share (EPS)

This calculation is made using a firm's net income divided by the number of 
outstanding shares of its common stock. A higher EPS indicates that the firm is
more profitable in comparison to others with lower EPS values. EPS is best used
as a comparison metric between other stocks rather than as an individualized 
rating [15].

$$
\begin{split}
 \begin{aligned}
\text{EPS} & = \frac{\text{Net Profit}} {\text{Outstanding Shares Of Common Stock}}
  \end{aligned}
\end{split}
$$

### Return on Assets (ROA)

The Return on Assets ratio indicates how profitable a firm is related to its 
assets. This value provides insight into how well a firm uses its assets to
generate profits. In relative terms, a higher Return on Asset value means that
the firm more effectively uses its assets in profit generation [16].

$$
\begin{split}
 \begin{aligned}
\text{ROA} & = \frac{\text{Net Income}} {\text{Total Assets}}
  \end{aligned}
\end{split}
$$

### Return on Equity (ROE)

Return on Equity shows how well a firm manages its overall equity which is
calculated taking its net income and dividing it by subtracting the firms assets
minus all debts from the balance sheet. This in short can be considered the
firms return on net assets. Different industries utilize debt financing as part
of their normal operations. The Return on Equity removes this from consideration
and thus provides a more balanced view regardless of industry dependent 
operation methods [17].

$$
\begin{split}
 \begin{aligned}
\text{ROE} & = \frac{\text{Net Income}} {\text{Total Equity}}
  \end{aligned}
\end{split}
$$

### Net Profit Margin

The Net Profit Margin is an important, and widely used ratio that shows how well
a firm is operating. It is calculated using the net profit the firm generates 
and dividing by its total revenue. This ratio is used to compare firms against
each other and considers how well the firm controls its costs and overhead a 
higher Net Profit Margin is better than lower values [18].

$$
\begin{split}
 \begin{aligned}
\text{Net Profit Margin} & = \frac{\text{Net Profit}} {\text{Revenue}}
  \end{aligned}
\end{split}
$$

### Trailing 1-Month Return (TM)

Rate of change for the stock price from the beginning of the last month of a 
quarter and the end of the quarter. A higher return rate is better than a lower 
rate [19].

$$
\begin{split}
 \begin{aligned}
\text{Rate of Return} & = \frac{(\text{Close Price}_{End} - \text{Close Price}_{Start})} {\text{Close Price}_{Start}}
  \end{aligned}
\end{split}
$$

\newpage


## DEA Variables and Model Methodology

### Feature Engineering

```{r GetAnalysisTimeWindow, fig.width=7.9, fig.height=5.4, echo=FALSE}

img <- readPNG("Reference/Analysis-Time-Block-Diagram.png")
 grid.raster(img)

```

The methodology used in building the DEA model for this study uses a mix of 
values from corporate quarterly reports and calculated market price ratios. The 
quarterly reports are measured in three (3) month segment time periods and the
market price ratios are measured using one (1) month time periods. Using shorter
time periods on the market prices based ratios is intended to capture external 
forces that can impact the short-term price movement of a stock, such as news 
events, and other economic events that occur outside of a firms financial reporting
schedules.

The Q1 Analysis Example diagram above describes these two (2) differing variable 
sets. The Quarterly Financial Ratios box within the DEA Analysis Window shows
the models financial ratio variables derived from the quarters financial reports.
These variables are: Debt to Equity, Price to Book, Earnings per Share, Return 
on Assets, Return on Equity, and the Net Profit Margin. The Monthly Ratios in
the DEA Analysis Windows list the variables used for the short-term analysis
which are derived solely from market activity: Beta, Sigma, and the monthly 
Trailing Rate of Return.

The portfolio entry date using this model is assumed to be the first trading day
after the end of a quarter. The holding periods are the three (3) consecutive 
months after entry. The diagram indicates the months defined for each quarter,
and the holding period months based on the quarter that the analysis has been
calculated.

The Q1 example shows that an analysis for the first quarter of the year covers
a financial reporting period from January through March, and the short-term
monthly variables are calculated for the last month of the same quarter (March).
The entry month is April, and the holding periods for backtesting purposes are 
for the months of April, May, and June.

# Empirical Findings

Using a four (4) input, five (5) output input-oriented DEA model with
historical stock market data is used for analysis in this study. A stock
must be determined to be 100% efficient with a score of 1.0 as
determined by the DEA model to be included within a portfolio.

## Multiplier Model Analysis

```{r Q1MuliplierModel, eval=TRUE, echo=FALSE, message=FALSE}

#################
# Q1 CALCULATION
#################

# CONVERT DATFRAME TO MATRIX FOR PROCESSING
converted_data <- data.matrix(df_Q1, rownames.force=NA)

# SLICE THE X AND Y VARIABLES FOR DEA
Q1_x <- data.matrix(converted_data[,2:5])  # ALL ROWS, COLS 2,3,4,5
Q1_y <- data.matrix(converted_data[,6:10]) # ALL ROWS, COLS 6,7,8,9,10

# SET THE LOOP COUNT AND DATA VARIABLE SIZES FOR DEA MODEL ANALYSIS
NX <- ncol(Q1_x); NY <- ncol(Q1_y); ND <- nrow(Q1_x)
xdata <- Q1_x[1:ND,]
dim(xdata) <- c(ND, NX) 
ydata <- Q1_y[1:ND,]
dim(ydata) <- c(ND, NY)

mm1.efficiency <- matrix(rep(-1.0, ND), nrow=ND)
mm1.lambda     <- matrix(rep(-1.0, ND^2), nrow=ND)
mm1.vweight    <- matrix(rep(-1.0, ND*NX), nrow=ND) 
mm1.uweight    <- matrix(rep(-1.0, ND*NY), nrow=ND) 
mm1.xslack     <- matrix(rep(-1.0, ND*NX), nrow=ND) 
mm1.yslack     <- matrix(rep(-1.0, ND*NY), nrow=ND) 

mm1names <- TRA::DEAnames(NX, NY, ND)

xnames <- c("Beta $v_1$", "Sigma $v_2$", "DtoE $v_3$", "PtoB $v_4$")
ynames <- c("NetMgn $u_1$", "EPS $u_2$", "ROA $u_3$", "ROE $u_4$", "TM $u_5$")

for (k in 1:ND) {

  result <- MIPModel() |>
  add_variable(vweight[i], i = 1:NX, type = "continuous", lb = 0)   |>
  add_variable(uweight[r], r = 1:NY, type = "continuous", lb = 0)   |>
  set_objective(sum_expr(uweight[r] * ydata[k,r], r = 1:NY), "max") |>
  add_constraint(sum_expr(vweight[i] * xdata[k,i], i = 1:NX) == 1)  |>
  add_constraint((sum_expr(uweight[r] * ydata[j,r], r = 1:NY)-
                    sum_expr(vweight[i] * xdata[j,i], i = 1:NX)) 
                 <= 0, j = 1:ND)
  result

  result <- solve_model(result, with_ROI(solver = "glpk", 
                                         verbose = FALSE))
  mm1.efficiency[k] <- objective_value (result) 

  # Get the output weights
  tempvweight <- get_solution(result, vweight[i])
  mm1.vweight[k,] <- tempvweight[,3]

  # Get the input weights
  tempuweight <- get_solution(result, uweight[i])
  mm1.uweight[k,] <- tempuweight[,3]
  templambda <- as.matrix(get_row_duals(result))
  mm1.lambda[k,] <- templambda [-1]
  # Drops the first dual value since that 
  #    constraint since is for setting denom=1
 }

mm1.input_wts  <- cbind(Q1_DMUnames,
                        format(mm1.efficiency, digits=2, nsmall=2),
                        format(mm1.vweight, digits=2, nsmall=2))
only_efficient_inputs <- mm1.input_wts[mm1.input_wts[,2] >= 1.0,]

mm1.output_wts <- cbind(Q1_DMUnames,
                        format(mm1.efficiency, digits=2, nsmall=2),
                        format(mm1.uweight, digits=2, nsmall=2))
only_efficient_outputs <- mm1.output_wts[mm1.output_wts[,2] >= 1.0,]

mm1.combined <- cbind (Q1_DMUnames,
                       format(mm1.efficiency, digits=2, nsmall=2), 
                       format(mm1.vweight, digits=2, nsmall=2), 
                       format(mm1.uweight, digits=2, nsmall=2))

mm1.combined_lambda <- cbind(Q1_DMUnames,
                       format(mm1.efficiency, digits=2, nsmall=2), 
                       format(mm1.lambda, digits=2, nsmall=2))

# SLICE OFF ONLY THE STOCKS THAT HAVE AN EFFICIENCY OF ONE (1)
Q1_only_efficient_stocks_MM <- mm1.combined[mm1.combined[,2] >= 1.0,]

colnames(Q1_only_efficient_stocks_MM) <- c("DMU","Score", "X1", "X2", "X3", "X4",
                                        "Y1", "Y2", "Y3", "Y4", "Y5")

efficient_MM <- Q1_only_efficient_stocks_MM[,3:11]

efficient_MM[0] <- format(efficient_MM[0], digits=4)
efficient_MM[1] <- format(efficient_MM[1], digits=4)
efficient_MM[2] <- format(efficient_MM[2], digits=4)
efficient_MM[3] <- format(efficient_MM[3], digits=4)
efficient_MM[4] <- format(efficient_MM[4], digits=4)
efficient_MM[5] <- format(efficient_MM[5], digits=4)
efficient_MM[6] <- format(efficient_MM[6], digits=4)
efficient_MM[7] <- format(efficient_MM[7], digits=4)

Q1_display_efficient_MM <- cbind(Q1_only_efficient_stocks_MM[,1], efficient_MM)

Q1_number_of_efficient_stocks <- nrow(Q1_only_efficient_stocks_MM)

# TOO MANY LAMBDA VALUES TO VIEW IN A TYPICAL STOCK SECTOR DATA SET
#only_efficient_stocks_MM_labmda <- mm1.combined_lambda[mm1.combined_lambda[,2] >= 1.0,]

Q1_df_MM_io_data <- df_Q1[df_Q1$DMU %in% Q1_only_efficient_stocks_MM,]

```

```{r Q2MuliplierModel, eval=TRUE, echo=FALSE, message=FALSE}

#################
# Q2 CALCULATION
#################

# CONVERT DATFRAME TO MATRIX FOR PROCESSING
converted_data <- data.matrix(df_Q2, rownames.force=NA)

# SLICE THE X AND Y VARIABLES FOR DEA
Q2_x <- data.matrix(converted_data[,2:5])  # ALL ROWS, COLS 2,3,4,5
Q2_y <- data.matrix(converted_data[,6:10]) # ALL ROWS, COLS 6,7,8,9,10

# SET THE LOOP COUNT AND DATA VARIABLE SIZES FOR DEA MODEL ANALYSIS
NX <- ncol(Q2_x); NY <- ncol(Q2_y); ND <- nrow(Q2_x)
xdata <- Q2_x[1:ND,]
dim(xdata) <- c(ND, NX) 
ydata <- Q2_y[1:ND,]
dim(ydata) <- c(ND, NY)

mm1.efficiency <- matrix(rep(-1.0, ND), nrow=ND)
mm1.lambda     <- matrix(rep(-1.0, ND^2), nrow=ND)
mm1.vweight    <- matrix(rep(-1.0, ND*NX), nrow=ND) 
mm1.uweight    <- matrix(rep(-1.0, ND*NY), nrow=ND) 
mm1.xslack     <- matrix(rep(-1.0, ND*NX), nrow=ND) 
mm1.yslack     <- matrix(rep(-1.0, ND*NY), nrow=ND) 

mm1names <- TRA::DEAnames(NX, NY, ND)

xnames <- c("Beta $v_1$", "Sigma $v_2$", "DtoE $v_3$", "PtoB $v_4$")
ynames <- c("NetMgn $u_1$", "EPS $u_2$", "ROA $u_3$", "ROE $u_4$", "TM $u_5$")

for (k in 1:ND) {

  result <- MIPModel() |>
  add_variable(vweight[i], i = 1:NX, type = "continuous", lb = 0)   |>
  add_variable(uweight[r], r = 1:NY, type = "continuous", lb = 0)   |>
  set_objective(sum_expr(uweight[r] * ydata[k,r], r = 1:NY), "max") |>
  add_constraint(sum_expr(vweight[i] * xdata[k,i], i = 1:NX) == 1)  |>
  add_constraint((sum_expr(uweight[r] * ydata[j,r], r = 1:NY)-
                    sum_expr(vweight[i] * xdata[j,i], i = 1:NX)) 
                 <= 0, j = 1:ND)
  result

  result <- solve_model(result, with_ROI(solver = "glpk", 
                                         verbose = FALSE))
  mm1.efficiency[k] <- objective_value (result) 

  # Get the output weights
  tempvweight <- get_solution(result, vweight[i])
  mm1.vweight[k,] <- tempvweight[,3]

  # Get the input weights
  tempuweight <- get_solution(result, uweight[i])
  mm1.uweight[k,] <- tempuweight[,3]
  templambda <- as.matrix(get_row_duals(result))
  mm1.lambda[k,] <- templambda [-1]
  # Drops the first dual value since that 
  #    constraint since is for setting denom=1
 }

mm1.input_wts  <- cbind(Q2_DMUnames,
                        format(mm1.efficiency, digits=2, nsmall=2),
                        format(mm1.vweight, digits=2, nsmall=2))
only_efficient_inputs <- mm1.input_wts[mm1.input_wts[,2] >= 1.0,]

mm1.output_wts <- cbind(Q2_DMUnames,
                        format(mm1.efficiency, digits=2, nsmall=2),
                        format(mm1.uweight, digits=2, nsmall=2))
only_efficient_outputs <- mm1.output_wts[mm1.output_wts[,2] >= 1.0,]

mm1.combined <- cbind (Q2_DMUnames,
                       format(mm1.efficiency, digits=2, nsmall=2), 
                       format(mm1.vweight, digits=2, nsmall=2), 
                       format(mm1.uweight, digits=2, nsmall=2))

mm1.combined_lambda <- cbind(Q2_DMUnames,
                       format(mm1.efficiency, digits=2, nsmall=2), 
                       format(mm1.lambda, digits=2, nsmall=2))

# SLICE OFF ONLY THE STOCKS THAT HAVE AN EFFICIENCY OF ONE (1)
Q2_only_efficient_stocks_MM <- mm1.combined[mm1.combined[,2] >= 1.0,]

colnames(Q2_only_efficient_stocks_MM) <- c("DMU","Score", "X1", "X2", "X3", "X4",
                                        "Y1", "Y2", "Y3", "Y4", "Y5")

efficient_MM <- Q2_only_efficient_stocks_MM[,3:11]

efficient_MM[0] <- format(efficient_MM[0], digits=4)
efficient_MM[1] <- format(efficient_MM[1], digits=4)
efficient_MM[2] <- format(efficient_MM[2], digits=4)
efficient_MM[3] <- format(efficient_MM[3], digits=4)
efficient_MM[4] <- format(efficient_MM[4], digits=4)
efficient_MM[5] <- format(efficient_MM[5], digits=4)
efficient_MM[6] <- format(efficient_MM[6], digits=4)
efficient_MM[7] <- format(efficient_MM[7], digits=4)

Q2_display_efficient_MM <- cbind(Q2_only_efficient_stocks_MM[,1], efficient_MM)

Q2_number_of_efficient_stocks <- nrow(Q2_only_efficient_stocks_MM)

# TOO MANY LAMBDA VALUES TO VIEW IN A TYPICAL STOCK SECTOR DATA SET
#only_efficient_stocks_MM_labmda <- mm1.combined_lambda[mm1.combined_lambda[,2] >= 1.0,]

Q2_df_MM_io_data <- df_Q2[df_Q2$DMU %in% Q2_only_efficient_stocks_MM,]

```

```{r Q3MuliplierModel, eval=TRUE, echo=FALSE, message=FALSE}

#################
# Q3 CALCULATION
#################

# CONVERT DATFRAME TO MATRIX FOR PROCESSING
converted_data <- data.matrix(df_Q3, rownames.force=NA)

# SLICE THE X AND Y VARIABLES FOR DEA
Q3_x <- data.matrix(converted_data[,2:5])  # ALL ROWS, COLS 2,3,4,5
Q3_y <- data.matrix(converted_data[,6:10]) # ALL ROWS, COLS 6,7,8,9,10

# SET THE LOOP COUNT AND DATA VARIABLE SIZES FOR DEA MODEL ANALYSIS
NX <- ncol(Q3_x); NY <- ncol(Q3_y); ND <- nrow(Q3_x)
xdata <- Q3_x[1:ND,]
dim(xdata) <- c(ND, NX) 
ydata <- Q3_y[1:ND,]
dim(ydata) <- c(ND, NY)

mm1.efficiency <- matrix(rep(-1.0, ND), nrow=ND)
mm1.lambda     <- matrix(rep(-1.0, ND^2), nrow=ND)
mm1.vweight    <- matrix(rep(-1.0, ND*NX), nrow=ND) 
mm1.uweight    <- matrix(rep(-1.0, ND*NY), nrow=ND) 
mm1.xslack     <- matrix(rep(-1.0, ND*NX), nrow=ND) 
mm1.yslack     <- matrix(rep(-1.0, ND*NY), nrow=ND) 

mm1names <- TRA::DEAnames(NX, NY, ND)

xnames <- c("Beta $v_1$", "Sigma $v_2$", "DtoE $v_3$", "PtoB $v_4$")
ynames <- c("NetMgn $u_1$", "EPS $u_2$", "ROA $u_3$", "ROE $u_4$", "TM $u_5$")

for (k in 1:ND) {
  
  result <- MIPModel() |>
    add_variable(vweight[i], i = 1:NX, type = "continuous", lb = 0)   |>
    add_variable(uweight[r], r = 1:NY, type = "continuous", lb = 0)   |>
    set_objective(sum_expr(uweight[r] * ydata[k,r], r = 1:NY), "max") |>
    add_constraint(sum_expr(vweight[i] * xdata[k,i], i = 1:NX) == 1)  |>
    add_constraint((sum_expr(uweight[r] * ydata[j,r], r = 1:NY)-
                      sum_expr(vweight[i] * xdata[j,i], i = 1:NX)) 
                   <= 0, j = 1:ND)
  result
  
  result <- solve_model(result, with_ROI(solver = "glpk", 
                                         verbose = FALSE))
  mm1.efficiency[k] <- objective_value (result) 
  
  # Get the output weights
  tempvweight <- get_solution(result, vweight[i])
  mm1.vweight[k,] <- tempvweight[,3]
  
  # Get the input weights
  tempuweight <- get_solution(result, uweight[i])
  mm1.uweight[k,] <- tempuweight[,3]
  templambda <- as.matrix(get_row_duals(result))
  mm1.lambda[k,] <- templambda [-1]
  # Drops the first dual value since that 
  #    constraint since is for setting denom=1
}

mm1.input_wts  <- cbind(Q3_DMUnames,
                        format(mm1.efficiency, digits=2, nsmall=2),
                        format(mm1.vweight, digits=2, nsmall=2))
only_efficient_inputs <- mm1.input_wts[mm1.input_wts[,2] >= 1.0,]

mm1.output_wts <- cbind(Q3_DMUnames,
                        format(mm1.efficiency, digits=2, nsmall=2),
                        format(mm1.uweight, digits=2, nsmall=2))
only_efficient_outputs <- mm1.output_wts[mm1.output_wts[,2] >= 1.0,]

mm1.combined <- cbind (Q3_DMUnames,
                       format(mm1.efficiency, digits=2, nsmall=2), 
                       format(mm1.vweight, digits=2, nsmall=2), 
                       format(mm1.uweight, digits=2, nsmall=2))

mm1.combined_lambda <- cbind(Q3_DMUnames,
                             format(mm1.efficiency, digits=2, nsmall=2), 
                             format(mm1.lambda, digits=2, nsmall=2))

# SLICE OFF ONLY THE STOCKS THAT HAVE AN EFFICIENCY OF ONE (1)
Q3_only_efficient_stocks_MM <- mm1.combined[mm1.combined[,2] >= 1.0,]

colnames(Q3_only_efficient_stocks_MM) <- c("DMU","Score", "X1", "X2", "X3", "X4",
                                           "Y1", "Y2", "Y3", "Y4", "Y5")

efficient_MM <- Q3_only_efficient_stocks_MM[,3:11]

efficient_MM[0] <- format(efficient_MM[0], digits=4)
efficient_MM[1] <- format(efficient_MM[1], digits=4)
efficient_MM[2] <- format(efficient_MM[2], digits=4)
efficient_MM[3] <- format(efficient_MM[3], digits=4)
efficient_MM[4] <- format(efficient_MM[4], digits=4)
efficient_MM[5] <- format(efficient_MM[5], digits=4)
efficient_MM[6] <- format(efficient_MM[6], digits=4)
efficient_MM[7] <- format(efficient_MM[7], digits=4)

Q3_display_efficient_MM <- cbind(Q3_only_efficient_stocks_MM[,1], efficient_MM)

Q3_number_of_efficient_stocks <- nrow(Q3_only_efficient_stocks_MM)

# TOO MANY LAMBDA VALUES TO VIEW IN A TYPICAL STOCK SECTOR DATA SET
#only_efficient_stocks_MM_labmda <- mm1.combined_lambda[mm1.combined_lambda[,2] >= 1.0,]

Q3_df_MM_io_data <- df_Q3[df_Q3$DMU %in% Q3_only_efficient_stocks_MM,]

```

```{r Q4MuliplierModel, eval=TRUE, echo=FALSE, message=FALSE}

#################
# Q4 CALCULATION
#################

# CONVERT DATFRAME TO MATRIX FOR PROCESSING
converted_data <- data.matrix(df_Q4, rownames.force=NA)

# SLICE THE X AND Y VARIABLES FOR DEA
Q4_x <- data.matrix(converted_data[,2:5])  # ALL ROWS, COLS 2,3,4,5
Q4_y <- data.matrix(converted_data[,6:10]) # ALL ROWS, COLS 6,7,8,9,10

# SET THE LOOP COUNT AND DATA VARIABLE SIZES FOR DEA MODEL ANALYSIS
NX <- ncol(Q4_x); NY <- ncol(Q4_y); ND <- nrow(Q4_x)
xdata <- Q4_x[1:ND,]
dim(xdata) <- c(ND, NX) 
ydata <- Q4_y[1:ND,]
dim(ydata) <- c(ND, NY)

mm1.efficiency <- matrix(rep(-1.0, ND), nrow=ND)
mm1.lambda     <- matrix(rep(-1.0, ND^2), nrow=ND)
mm1.vweight    <- matrix(rep(-1.0, ND*NX), nrow=ND) 
mm1.uweight    <- matrix(rep(-1.0, ND*NY), nrow=ND) 
mm1.xslack     <- matrix(rep(-1.0, ND*NX), nrow=ND) 
mm1.yslack     <- matrix(rep(-1.0, ND*NY), nrow=ND) 

mm1names <- TRA::DEAnames(NX, NY, ND)

xnames <- c("Beta $v_1$", "Sigma $v_2$", "DtoE $v_3$", "PtoB $v_4$")
ynames <- c("NetMgn $u_1$", "EPS $u_2$", "ROA $u_3$", "ROE $u_4$", "TM $u_5$")

for (k in 1:ND) {
  
  result <- MIPModel() |>
    add_variable(vweight[i], i = 1:NX, type = "continuous", lb = 0)   |>
    add_variable(uweight[r], r = 1:NY, type = "continuous", lb = 0)   |>
    set_objective(sum_expr(uweight[r] * ydata[k,r], r = 1:NY), "max") |>
    add_constraint(sum_expr(vweight[i] * xdata[k,i], i = 1:NX) == 1)  |>
    add_constraint((sum_expr(uweight[r] * ydata[j,r], r = 1:NY)-
                      sum_expr(vweight[i] * xdata[j,i], i = 1:NX)) 
                   <= 0, j = 1:ND)
  result
  
  result <- solve_model(result, with_ROI(solver = "glpk", 
                                         verbose = FALSE))
  mm1.efficiency[k] <- objective_value (result) 
  
  # Get the output weights
  tempvweight <- get_solution(result, vweight[i])
  mm1.vweight[k,] <- tempvweight[,3]
  
  # Get the input weights
  tempuweight <- get_solution(result, uweight[i])
  mm1.uweight[k,] <- tempuweight[,3]
  templambda <- as.matrix(get_row_duals(result))
  mm1.lambda[k,] <- templambda [-1]
  # Drops the first dual value since that 
  #    constraint since is for setting denom=1
}

mm1.input_wts  <- cbind(Q4_DMUnames,
                        format(mm1.efficiency, digits=2, nsmall=2),
                        format(mm1.vweight, digits=2, nsmall=2))
only_efficient_inputs <- mm1.input_wts[mm1.input_wts[,2] >= 1.0,]

mm1.output_wts <- cbind(Q4_DMUnames,
                        format(mm1.efficiency, digits=2, nsmall=2),
                        format(mm1.uweight, digits=2, nsmall=2))
only_efficient_outputs <- mm1.output_wts[mm1.output_wts[,2] >= 1.0,]

mm1.combined <- cbind (Q4_DMUnames,
                       format(mm1.efficiency, digits=2, nsmall=2), 
                       format(mm1.vweight, digits=2, nsmall=2), 
                       format(mm1.uweight, digits=2, nsmall=2))

mm1.combined_lambda <- cbind(Q4_DMUnames,
                             format(mm1.efficiency, digits=2, nsmall=2), 
                             format(mm1.lambda, digits=2, nsmall=2))

# SLICE OFF ONLY THE STOCKS THAT HAVE AN EFFICIENCY OF ONE (1)
Q4_only_efficient_stocks_MM <- mm1.combined[mm1.combined[,2] >= 1.0,]

colnames(Q4_only_efficient_stocks_MM) <- c("DMU","Score", "X1", "X2", "X3", "X4",
                                           "Y1", "Y2", "Y3", "Y4", "Y5")

efficient_MM <- Q4_only_efficient_stocks_MM[,3:11]

efficient_MM[0] <- format(efficient_MM[0], digits=4)
efficient_MM[1] <- format(efficient_MM[1], digits=4)
efficient_MM[2] <- format(efficient_MM[2], digits=4)
efficient_MM[3] <- format(efficient_MM[3], digits=4)
efficient_MM[4] <- format(efficient_MM[4], digits=4)
efficient_MM[5] <- format(efficient_MM[5], digits=4)
efficient_MM[6] <- format(efficient_MM[6], digits=4)
efficient_MM[7] <- format(efficient_MM[7], digits=4)

Q4_display_efficient_MM <- cbind(Q4_only_efficient_stocks_MM[,1], efficient_MM)

Q4_number_of_efficient_stocks <- nrow(Q4_only_efficient_stocks_MM)

# TOO MANY LAMBDA VALUES TO VIEW IN A TYPICAL STOCK SECTOR DATA SET
#only_efficient_stocks_MM_labmda <- mm1.combined_lambda[mm1.combined_lambda[,2] >= 1.0,]

Q4_df_MM_io_data <- df_Q4[df_Q4$DMU %in% Q4_only_efficient_stocks_MM,]

```

\vspace{12pt}

In the context of each quarter (Q1-Q4) within the `r Q1_SECTOR` sector, the following data overview provides insights into the size of the data set, the number of identified efficient stocks based on DEA analysis, and the percentage of efficient stocks selected from the initial data set.

This quarterly analysis provides a nuanced understanding of the efficiency landscape within the `r Q1_SECTOR` sector. The varying efficiency levels emphasize the importance of adaptability in stock selection strategies based on the evolving efficiency dynamics in the market.

\vspace{12pt}

**Data Summary and Overview:**

\vspace{12pt}

**Q1 (Jan - Mar)**

`r Q1_SECTOR` Sector Data Size: `r Q1_number_of_source_records`

100% Efficient Stocks (DEA): `r Q1_number_of_efficient_stocks`

Percentage of Data Selected: `r format((Q1_number_of_efficient_stocks/Q1_number_of_source_records)*100, nsmall=2, digits=2)`%

\vspace{12pt}

**Q2 (Apr - Jun)**

`r Q2_SECTOR` Sector Data Size: `r Q2_number_of_source_records`

100% Efficient Stocks (DEA): `r Q2_number_of_efficient_stocks`

Percentage of Data Selected: `r format((Q2_number_of_efficient_stocks/Q2_number_of_source_records)*100, nsmall=2, digits=2)`%

\vspace{12pt}

**Q3 (Jul - Sep)**

`r Q3_SECTOR` Sector Data Size: `r Q3_number_of_source_records`

100% Efficient Stocks (DEA): `r Q3_number_of_efficient_stocks`

Percentage of Data Selected: `r format((Q3_number_of_efficient_stocks/Q3_number_of_source_records)*100, nsmall=2, digits=2)`%

\vspace{12pt}

**Q4 (Oct - Dec)**

`r Q4_SECTOR` Sector Data Size: `r Q4_number_of_source_records`

100% Efficient Stocks (DEA): `r Q4_number_of_efficient_stocks`

Percentage of Data Selected: `r format((Q4_number_of_efficient_stocks/Q4_number_of_source_records)*100, nsmall=2, digits=2)`%

\vspace{12pt}

The variations in the number and percentage of efficient stocks suggest dynamic changes in stock efficiency within the `r Q1_SECTOR` sector over each quarter. Researchers and investors may be
able to leverage this analysis to make informed decisions about portfolio construction, potentially favoring periods with higher efficiency levels.

\newpage

### Efficient Stocks for Portfolio

Each quarterly portfolio below (Tables 1-4) aim to mitigate risks associated with inefficient resource use and sub optimal output generation by focusing on stocks with the highest efficiency ratings. Some industries may naturally have higher input requirements, and efficiency ratings should be contextualized accordingly. Continuous monitoring and periodic reevaluation of the portfolio are essential. Multipliers may change over time, reflecting shifts in efficiency dynamics. By incorporating input and output multipliers, the portfolio aims to include stocks with optimal resource utilization and effective output generation, contributing to a robust and efficient investment strategy.

```{r ShowEfficientStocks, echo=FALSE, message=FALSE}

# SHOW EFFICIENT STOCKS RETURNED FROM THE DEA MODEL
kbl (Q1_only_efficient_stocks_MM[,1:2], align="lc", booktabs=T, escape=F, digits=2, longtable=T,
     col.names=c("DMU", "Score $\\theta^{CRS}$"),
     caption =c("Q1 Multiplier Model Stock Portfolio Results")) |>
  kable_styling (latex_options = c("HOLD_position"))

# SHOW EFFICIENT STOCKS RETURNED FROM THE DEA MODEL
kbl (Q2_only_efficient_stocks_MM[,1:2], align="lc", booktabs=T, escape=F, digits=2, longtable=T,
     col.names=c("DMU", "Score $\\theta^{CRS}$"),
     caption =c("Q2 Multiplier Model Stock Portfolio Results")) |>
  kable_styling (latex_options = c("HOLD_position"))

# SHOW EFFICIENT STOCKS RETURNED FROM THE DEA MODEL
kbl (Q3_only_efficient_stocks_MM[,1:2], align="lc", booktabs=T, escape=F, digits=2, longtable=T,
     col.names=c("DMU", "Score $\\theta^{CRS}$"),
     caption =c("Q3 Multiplier Model Stock Portfolio Results")) |>
  kable_styling (latex_options = c("HOLD_position"))

# SHOW EFFICIENT STOCKS RETURNED FROM THE DEA MODEL
kbl (Q4_only_efficient_stocks_MM[,1:2], align="lc", booktabs=T, escape=F, digits=2, longtable=T,
     col.names=c("DMU", "Score $\\theta^{CRS}$"),
     caption =c("Q4 Multiplier Model Stock Portfolio Results")) |>
  kable_styling (latex_options = c("HOLD_position"))

```

### Multiplier Model Input and Output Data Analysis

To effectively interpret the DEA output for the input-oriented constant returns to scale multiplier model in the context of building a stock market portfolio, we will delve into the efficiency scores and associated multiplier values for each stock. The efficiency scores, derived from the DEA analysis, represent the relative efficiency of each stock in transforming input resources into output performance, with a score of 100% indicating maximum efficiency [2].

\vspace{12pt}

**Interpretation of Multipliers:**

\vspace{12pt}

**Input Multipliers (Beta, Sigma, DToE, PToB):**

Represents the factor by which the quantity of inputs should be reduced to achieve efficiency, keeping outputs constant. Negative values suggest that certain stocks are overusing inputs relative to their peers. A lower absolute value indicates a higher efficiency contribution. Positive values indicate over utilization of inputs. A lower absolute value suggests a more efficient use of resources.

**Output Multipliers (NetMrgn, EPS, ROA, ROE, TTMreturn):**

Factors by which the quantity of outputs can be increased for efficiency, keeping inputs constant.
High output multipliers (positive or negative) indicate inefficiencies in specific aspects. A lower absolute value suggests better efficiency in generating the corresponding output.

\vspace{12pt}

**Stock Selection Criteria:**

\vspace{12pt}

**Input Efficiency:**

Stocks with lower absolute values of input multipliers (Beta, Sigma, DToE, PToB) are prioritized for inclusion in the portfolio. This ensures a more efficient use of resources relative to their peers.

**Output Efficiency:**

Stocks with lower absolute values of output multipliers for key performance indicators (NetMrgn, EPS, ROA, ROE, TTMreturn) are favored. This indicates efficiency in generating outputs, contributing positively to the stock's overall efficiency rating.

The multipliers for the portfolio analysis of Q1 through Q4 are provided in tables 5 through 8 below:

```{r MultiplierModelIOs, echo=FALSE, message=FALSE}

kbl (Q1_display_efficient_MM, booktabs=T, escape=F, digits=2, longtable=F,
     col.names=c("DMU", xnames, ynames),
     caption =c("Q1 Multiplier Model Results for Perfectly Efficient Stocks"))  |>
  add_header_above(c(" " = 1, "Inputs (x)" = 4, "Outputs (y)" = 5))  |>
  kable_styling (latex_options = c("HOLD_position", "scale_down"))

kbl (Q2_display_efficient_MM, booktabs=T, escape=F, digits=2, longtable=F,
     col.names=c("DMU", xnames, ynames),
     caption =c("Q2 Multiplier Model Results for Perfectly Efficient Stocks"))  |>
  add_header_above(c(" " = 1, "Inputs (x)" = 4, "Outputs (y)" = 5))  |>
  kable_styling (latex_options = c("HOLD_position", "scale_down"))

kbl (Q3_display_efficient_MM, booktabs=T, escape=F, digits=2, longtable=F,
     col.names=c("DMU", xnames, ynames),
     caption =c("Q3 Multiplier Model Results for Perfectly Efficient Stocks"))  |>
  add_header_above(c(" " = 1, "Inputs (x)" = 4, "Outputs (y)" = 5))  |>
  kable_styling (latex_options = c("HOLD_position", "scale_down"))

kbl (Q4_display_efficient_MM, booktabs=T, escape=F, digits=2, longtable=F,
     col.names=c("DMU", xnames, ynames),
     caption =c("Q4 Multiplier Model Results for Perfectly Efficient Stocks"))  |>
  add_header_above(c(" " = 1, "Inputs (x)" = 4, "Outputs (y)" = 5))  |>
  kable_styling (latex_options = c("HOLD_position", "scale_down"))

#kbl (only_efficient_stocks_MM_labmda, booktabs=T, escape=F, digits=2, longtable=F,
#      col.names=c("DMU", "$\\theta^{CRS}$", mm1names$LambdanamesbyletterLX),
#      caption =c("Multiplier Model Results"))  |>
#   kable_styling (latex_options = c("hold_position", "scale_down")) |>
#   landscape()

```

\newpage

## Back-testing

### 1, 2, and 3 Period DEA Portfolio Performance Analysis

In the pursuit of constructing an optimized stock market portfolio, this research leverages DEA with an input-oriented constant returns to scale multiplier model. The primary objective is to include stocks with a 100% efficiency rating in the portfolio, as identified by the DEA analysis. This section interprets the DEA efficiency output and delves into the back-testing results, emphasizing efficiency scores, stock prices at different time points (entry price, 1-month, 2-month, and 3-month), and corresponding holding period return rates.

\vspace{12pt}

**DEA Efficiency Scores:**

Efficiency scores obtained from the DEA analysis serve as a critical criterion for stock selection. Stocks with a 100% efficiency rating are identified as those with scores equal to one (1). These scores signify optimal resource utilization, ensuring that the selected stocks are operating at peak efficiency relative to their peers.

\vspace{12pt}

**Entry Price:**

The entry price represents the initial price at which stocks are included in the portfolio based on the DEA efficiency analysis.

\vspace{12pt}

**1-Month, 2-Month, and 3-Month Prices:**

These prices represent the stock values at different time intervals after the portfolio's inception. The variation in prices over these horizons reflects the dynamic nature of the stock market.

\vspace{12pt}

**1-Month, 2-Month, and 3-Month Return Rates:**

Holding period return rates are crucial metrics to evaluate the performance of the portfolio over different time frames. These rates capture the percentage change in stock prices.

\vspace{12pt}

**High Efficiency and Positive Returns:**

Stocks with 100% efficiency ratings are expected to exhibit positive return rates, reflecting their optimal resource utilization. The correlation between efficiency scores and positive returns substantiates the effectiveness of the DEA-based stock selection.

\vspace{12pt}

**Efficiency and Price Volatility:**

While high efficiency suggests optimal operations, the volatility in stock prices may vary. It is essential to examine how efficiently rated stocks navigate market fluctuations and whether efficiency acts as a mitigating factor in the face of price volatility.

Analyzing each stock included within each quarterly portfolio (Tables 9-12), it is clear that not all stocks identified through DEA as 100% efficient provided a positive return rate. This holds for all quarters of this study. Further, the DEA generated quarterly portfolios contain differing mixtures of individual stocks. This differing portfolio mixture is expected, as corporate quarterly report financial ratios also differ from quarter to quarter.

```{r CalculateReturnRates, echo=FALSE, message=FALSE}
# FUNCTION TO CALCULATE THE RATE OF RETURN BETWEEN TWO PRICES
rateOfReturn <- function(endPrice, startPrice){
    format(round(as.numeric(((as.numeric(endPrice) - as.numeric(startPrice)) / as.numeric(startPrice))*100), 2), nsmall=2)
}

line_space <- cbind(" "," "," "," "," "," "," "," ")
colnames(line_space) <- c("sector_average_text","averageEntry", "averagePeriodOneP", "averagePeriodTwoP", "averagePeriodThreeP", "averagePeriodOne", "averagePeriodTwo", "averagePeriodThree")

sector_CRS_averages <- data.frame()

#######
# Q1
#######

# CALCULATE THE ONE YEAR RATE OF RETURN
Q1_periodOneReturnRate <- rateOfReturn(Q1_backtestingPrices$periodOnePrice, Q1_backtestingPrices$entryPrice)

# CALCUALTE THE THREE YEAR RATE OF RETURN
Q1_periodTwoReturnRate <- rateOfReturn(Q1_backtestingPrices$periodTwoPrice, Q1_backtestingPrices$entryPrice)

# CALCULATE THE FIVE YEAR RATE OF RETURN
Q1_periodThreeReturnRate <- rateOfReturn(Q1_backtestingPrices$periodThreePrice, Q1_backtestingPrices$entryPrice)

# BIND EACH CALCULATED RATE OF CHANGE AS COLUMNS
Q1_returnResults <- cbind(Q1_DMUnames, 
                       Q1_backtestingPrices$entryPrice,
                       Q1_backtestingPrices$periodOnePrice, 
                       Q1_backtestingPrices$periodTwoPrice,
                       Q1_backtestingPrices$periodThreePrice,
                       Q1_periodOneReturnRate, 
                       Q1_periodTwoReturnRate, 
                       Q1_periodThreeReturnRate)

# SET THE COLUMN NAMES OF THE RATE OF RETURN RESULTS
colnames(Q1_returnResults) <- c("DMU",
                             "entryPrice",
                             "periodOnePrice",
                             "periodTwoPrice",
                             "periodThreePrice",
                             "periodOne",
                             "periodTwo",
                             "periodThree")

# MERGE THE EFFICIENT DMU DATAFRAME WITH THE RATE OF RETURN RESULT DATAFRAME
# NOTE: INNER JOIN BY DMU NAME

# GET THE DMU AND EFFICIENCY SCORE
Q1_temp_MM <- Q1_only_efficient_stocks_MM[,1:2]

# NAME THE TEMP COLUMNS
colnames(Q1_temp_MM) <- c("DMU","Score")

# SLICE OFF ONLY THE STOCKS THAT HAVE AN EFFICIENCY OF ONE (1)
Q1_only_efficient_stocks_RETURNS <- Q1_temp_MM[Q1_temp_MM[,2] >= 1.0,]

# MERGE: INNER JOIN THE DATAFRAMES FOR BACKTESTING VALUES AND EFFICIENT DMUs
Q1_df_all = merge(x = Q1_only_efficient_stocks_RETURNS, y = Q1_returnResults, by = "DMU")

# CREATE THE CAPTION FOR THE REPORT USING THE SECTOR NAME SELECTED FOR STUDY
Q1_report_caption <- sprintf('%s %s Sector Portfolio Detail', Q1_Quarter, toupper(Q1_SECTOR))

# OUTPUT THE DMU, EFFICENCY SCORE, AND RATE OF RETURNS
kbl(Q1_df_all, align = "lcrrrrrrr", booktabs=T, digits=4, escape=F, row.names=F,
    col.names=c("DMU", "Score $\\theta^{CRS}$", "Entry", "1 MO" ,"2 MO" ,"3 MO" , "1 MO", "2 MO", "3 MO"),
  caption= Q1_report_caption) |>
  add_header_above(c(" " = 1, "Efficiency" = 1, "Stock Prices ($)" = 4, "Holding Period Returns (%)" = 3))  |>
  kable_styling(latex_options = c("HOLD_position", "scale_down"))


############################################################################
# GET THE CROSS-EFFICIENCY SCORES FROM THE MULTIPLIERDEA LIBRARY FUNCTION
############################################################################
#eff_result <- DeaMultiplierModel(xdata, ydata , "crs", "input")
#cross_result <- CrossEfficiency(xdata, ydata, "crs", "input")
#rownames(eff_result$Efficiency) <- Q1_DMUnames
###########################################################################

# CALCULATE NUMERICAL PRICE RETURNS
Q1_averageEntry <- format(sum(as.numeric(Q1_df_all$entryPrice)), digits=2, nsmall=2)
Q1_averagePeriodOneP <- format(sum(as.numeric(Q1_df_all$periodOnePrice)), digits=2, nsmall=2)
Q1_averagePeriodTwoP <- format(sum(as.numeric(Q1_df_all$periodTwoPrice)), digits=2, nsmall=2)
Q1_averagePeriodThreeP <- format(sum(as.numeric(Q1_df_all$periodThreePrice)), digits=2, nsmall=2)

# CALCULATE THE ONE MONTH RATE OF RETURN
Q1_averagePeriodOne <- format((((as.numeric(Q1_averagePeriodOneP) - as.numeric(Q1_averageEntry)) 
               / as.numeric(Q1_averageEntry))*100), digits=2, nsmall=2)

# CALCUALTE THE TWO MONTH RATE OF RETURN
Q1_averagePeriodTwo <- format((((as.numeric(Q1_averagePeriodTwoP) - as.numeric(Q1_averageEntry)) 
               / as.numeric(Q1_averageEntry))*100), digits=2, nsmall=2)

# CALCULATE THE THREE MONTH RATE OF RETURN
Q1_averagePeriodThree <- format((((as.numeric(Q1_averagePeriodThreeP) - as.numeric(Q1_averageEntry)) 
               / as.numeric(Q1_averageEntry))*100), digits=2, nsmall=2)

# BUILD THE OUTPUT DATA
Q1_sector_average_text <- sprintf('%s - %s', Q1_Quarter, Q1_SECTOR)
Q1_sector_CRS_averages <- cbind(Q1_sector_average_text, 
                          Q1_averageEntry,
                          Q1_averagePeriodOneP,
                          Q1_averagePeriodTwoP,
                          Q1_averagePeriodThreeP, 
                          Q1_averagePeriodOne, 
                          Q1_averagePeriodTwo, 
                          Q1_averagePeriodThree)

colnames(Q1_sector_CRS_averages) <- c("sector_average_text","averageEntry", "averagePeriodOneP", "averagePeriodTwoP", "averagePeriodThreeP", "averagePeriodOne", "averagePeriodTwo", "averagePeriodThree")

# SP500 RETURN CALCULATIONS
Q1_SP500periodOnereturnRate <- rateOfReturn(Q1_sp500_allPeriods$SP500periodOne, Q1_sp500_allPeriods$Entry)
Q1_SP500periodTworeturnRate <- rateOfReturn(Q1_sp500_allPeriods$SP500periodTwo, Q1_sp500_allPeriods$Entry)
Q1_SP500periodThreereturnRate <- rateOfReturn(Q1_sp500_allPeriods$SP500periodThree, Q1_sp500_allPeriods$Entry)

Q1_sp500results <- cbind(c("Q1 - S&P 500"), Q1_sp500_allPeriods, Q1_SP500periodOnereturnRate, Q1_SP500periodTworeturnRate, Q1_SP500periodThreereturnRate)

colnames(Q1_sp500results) <- c("sector_average_text","averageEntry", "averagePeriodOneP", "averagePeriodTwoP", "averagePeriodThreeP", "averagePeriodOne", "averagePeriodTwo", "averagePeriodThree")

sector_CRS_averages <- rbind(sector_CRS_averages, Q1_sector_CRS_averages)
sector_CRS_averages <- rbind(sector_CRS_averages, Q1_sp500results)


#######
# Q2
#######

# CALCULATE THE ONE YEAR RATE OF RETURN
Q2_periodOneReturnRate <- rateOfReturn(Q2_backtestingPrices$periodOnePrice, Q2_backtestingPrices$entryPrice)

# CALCUALTE THE THREE YEAR RATE OF RETURN
Q2_periodTwoReturnRate <- rateOfReturn(Q2_backtestingPrices$periodTwoPrice, Q2_backtestingPrices$entryPrice)

# CALCULATE THE FIVE YEAR RATE OF RETURN
Q2_periodThreeReturnRate <- rateOfReturn(Q2_backtestingPrices$periodThreePrice, Q2_backtestingPrices$entryPrice)

# BIND EACH CALCULATED RATE OF CHANGE AS COLUMNS
Q2_returnResults <- cbind(Q2_DMUnames, 
                       Q2_backtestingPrices$entryPrice,
                       Q2_backtestingPrices$periodOnePrice, 
                       Q2_backtestingPrices$periodTwoPrice,
                       Q2_backtestingPrices$periodThreePrice,
                       Q2_periodOneReturnRate, 
                       Q2_periodTwoReturnRate, 
                       Q2_periodThreeReturnRate)

# SET THE COLUMN NAMES OF THE RATE OF RETURN RESULTS
colnames(Q2_returnResults) <- c("DMU",
                             "entryPrice",
                             "periodOnePrice",
                             "periodTwoPrice",
                             "periodThreePrice",
                             "periodOne",
                             "periodTwo",
                             "periodThree")

# MERGE THE EFFICIENT DMU DATAFRAME WITH THE RATE OF RETURN RESULT DATAFRAME
# NOTE: INNER JOIN BY DMU NAME

# GET THE DMU AND EFFICIENCY SCORE
Q2_temp_MM <- Q2_only_efficient_stocks_MM[,1:2]

# NAME THE TEMP COLUMNS
colnames(Q2_temp_MM) <- c("DMU","Score")

# SLICE OFF ONLY THE STOCKS THAT HAVE AN EFFICIENCY OF ONE (1)
Q2_only_efficient_stocks_RETURNS <- Q2_temp_MM[Q2_temp_MM[,2] >= 1.0,]

# MERGE: INNER JOIN THE DATAFRAMES FOR BACKTESTING VALUES AND EFFICIENT DMUs
Q2_df_all = merge(x = Q2_only_efficient_stocks_RETURNS, y = Q2_returnResults, by = "DMU")

# CREATE THE CAPTION FOR THE REPORT USING THE SECTOR NAME SELECTED FOR STUDY
Q2_report_caption <- sprintf('%s %s Sector Portfolio Detail', Q2_Quarter, toupper(Q2_SECTOR))

# OUTPUT THE DMU, EFFICENCY SCORE, AND RATE OF RETURNS
kbl(Q2_df_all, align = "lcrrrrrrr", booktabs=T, digits=4, escape=F, row.names=F,
    col.names=c("DMU", "Score $\\theta^{CRS}$", "Entry", "1 MO" ,"2 MO" ,"3 MO" , "1 MO", "2 MO", "3 MO"),
  caption= Q2_report_caption) |>
  add_header_above(c(" " = 1, "Efficiency" = 1, "Stock Prices ($)" = 4, "Holding Period Returns (%)" = 3))  |>
  kable_styling(latex_options = c("HOLD_position", "scale_down"))


############################################################################
# GET THE CROSS-EFFICIENCY SCORES FROM THE MULTIPLIERDEA LIBRARY FUNCTION
############################################################################
#eff_result <- DeaMultiplierModel(xdata, ydata , "crs", "input")
#cross_result <- CrossEfficiency(xdata, ydata, "crs", "input")
#rownames(eff_result$Efficiency) <- Q1_DMUnames
###########################################################################

# CALCULATE NUMERICAL PRICE RETURNS
Q2_averageEntry <- format(sum(as.numeric(Q2_df_all$entryPrice)), digits=2, nsmall=2)
Q2_averagePeriodOneP <- format(sum(as.numeric(Q2_df_all$periodOnePrice)), digits=2, nsmall=2)
Q2_averagePeriodTwoP <- format(sum(as.numeric(Q2_df_all$periodTwoPrice)), digits=2, nsmall=2)
Q2_averagePeriodThreeP <- format(sum(as.numeric(Q2_df_all$periodThreePrice)), digits=2, nsmall=2)

# CALCULATE THE ONE MONTH RATE OF RETURN
Q2_averagePeriodOne <- format((((as.numeric(Q2_averagePeriodOneP) - as.numeric(Q2_averageEntry)) 
               / as.numeric(Q2_averageEntry))*100), digits=2, nsmall=2)

# CALCUALTE THE TWO MONTH RATE OF RETURN
Q2_averagePeriodTwo <- format((((as.numeric(Q2_averagePeriodTwoP) - as.numeric(Q2_averageEntry)) 
               / as.numeric(Q2_averageEntry))*100), digits=2, nsmall=2)

# CALCULATE THE THREE MONTH RATE OF RETURN
Q2_averagePeriodThree <- format((((as.numeric(Q2_averagePeriodThreeP) - as.numeric(Q2_averageEntry)) 
               / as.numeric(Q2_averageEntry))*100), digits=2, nsmall=2)

# BUILD THE OUTPUT DATA
Q2_sector_average_text <- sprintf('%s - %s', Q2_Quarter, Q2_SECTOR)
Q2_sector_CRS_averages <- cbind(Q2_sector_average_text,
                                Q2_averageEntry, 
                                Q2_averagePeriodOneP, 
                                Q2_averagePeriodTwoP, 
                                Q2_averagePeriodThreeP, 
                                Q2_averagePeriodOne, 
                                Q2_averagePeriodTwo, 
                                Q2_averagePeriodThree)

colnames(Q2_sector_CRS_averages) <- c("sector_average_text","averageEntry", "averagePeriodOneP", "averagePeriodTwoP", "averagePeriodThreeP", "averagePeriodOne", "averagePeriodTwo", "averagePeriodThree")

# SP500 RETURN CALCULATIONS
Q2_SP500periodOnereturnRate <- rateOfReturn(Q2_sp500_allPeriods$SP500periodOne, Q2_sp500_allPeriods$Entry)
Q2_SP500periodTworeturnRate <- rateOfReturn(Q2_sp500_allPeriods$SP500periodTwo, Q2_sp500_allPeriods$Entry)
Q2_SP500periodThreereturnRate <- rateOfReturn(Q2_sp500_allPeriods$SP500periodThree, Q2_sp500_allPeriods$Entry)

Q2_sp500results <- cbind(c("Q2 - S&P 500"), Q2_sp500_allPeriods, Q2_SP500periodOnereturnRate, Q2_SP500periodTworeturnRate, Q2_SP500periodThreereturnRate)

colnames(Q2_sp500results) <- c("sector_average_text","averageEntry", "averagePeriodOneP", "averagePeriodTwoP", "averagePeriodThreeP", "averagePeriodOne", "averagePeriodTwo", "averagePeriodThree")

sector_CRS_averages <- rbind(sector_CRS_averages, line_space)
sector_CRS_averages <- rbind(sector_CRS_averages, Q2_sector_CRS_averages)
sector_CRS_averages <- rbind(sector_CRS_averages, Q2_sp500results)


#######
# Q3
#######

# CALCULATE THE ONE YEAR RATE OF RETURN
Q3_periodOneReturnRate <- rateOfReturn(Q3_backtestingPrices$periodOnePrice, Q3_backtestingPrices$entryPrice)

# CALCUALTE THE THREE YEAR RATE OF RETURN
Q3_periodTwoReturnRate <- rateOfReturn(Q3_backtestingPrices$periodTwoPrice, Q3_backtestingPrices$entryPrice)

# CALCULATE THE FIVE YEAR RATE OF RETURN
Q3_periodThreeReturnRate <- rateOfReturn(Q3_backtestingPrices$periodThreePrice, Q3_backtestingPrices$entryPrice)

# BIND EACH CALCULATED RATE OF CHANGE AS COLUMNS
Q3_returnResults <- cbind(Q3_DMUnames, 
                          Q3_backtestingPrices$entryPrice,
                          Q3_backtestingPrices$periodOnePrice, 
                          Q3_backtestingPrices$periodTwoPrice,
                          Q3_backtestingPrices$periodThreePrice,
                          Q3_periodOneReturnRate, 
                          Q3_periodTwoReturnRate, 
                          Q3_periodThreeReturnRate)

# SET THE COLUMN NAMES OF THE RATE OF RETURN RESULTS
colnames(Q3_returnResults) <- c("DMU",
                                "entryPrice",
                                "periodOnePrice",
                                "periodTwoPrice",
                                "periodThreePrice",
                                "periodOne",
                                "periodTwo",
                                "periodThree")

# MERGE THE EFFICIENT DMU DATAFRAME WITH THE RATE OF RETURN RESULT DATAFRAME
# NOTE: INNER JOIN BY DMU NAME

# GET THE DMU AND EFFICIENCY SCORE
Q3_temp_MM <- Q3_only_efficient_stocks_MM[,1:2]

# NAME THE TEMP COLUMNS
colnames(Q3_temp_MM) <- c("DMU","Score")

# SLICE OFF ONLY THE STOCKS THAT HAVE AN EFFICIENCY OF ONE (1)
Q3_only_efficient_stocks_RETURNS <- Q3_temp_MM[Q3_temp_MM[,2] >= 1.0,]

# MERGE: INNER JOIN THE DATAFRAMES FOR BACKTESTING VALUES AND EFFICIENT DMUs
Q3_df_all = merge(x = Q3_only_efficient_stocks_RETURNS, y = Q3_returnResults, by = "DMU")

# CREATE THE CAPTION FOR THE REPORT USING THE SECTOR NAME SELECTED FOR STUDY
Q3_report_caption <- sprintf('%s %s Sector Portfolio Detail', Q3_Quarter, toupper(Q3_SECTOR))

# OUTPUT THE DMU, EFFICENCY SCORE, AND RATE OF RETURNS
kbl(Q3_df_all, align = "lcrrrrrrr", booktabs=T, digits=4, escape=F, row.names=F,
    col.names=c("DMU", "Score $\\theta^{CRS}$", "Entry", "1 MO" ,"2 MO" ,"3 MO" , "1 MO", "2 MO", "3 MO"),
    caption= Q3_report_caption) |>
  add_header_above(c(" " = 1, "Efficiency" = 1, "Stock Prices ($)" = 4, "Holding Period Returns (%)" = 3))  |>
  kable_styling(latex_options = c("HOLD_position", "scale_down"))


############################################################################
# GET THE CROSS-EFFICIENCY SCORES FROM THE MULTIPLIERDEA LIBRARY FUNCTION
############################################################################
#eff_result <- DeaMultiplierModel(xdata, ydata , "crs", "input")
#cross_result <- CrossEfficiency(xdata, ydata, "crs", "input")
#rownames(eff_result$Efficiency) <- Q1_DMUnames
###########################################################################

# CALCULATE NUMERICAL PRICE RETURNS
Q3_averageEntry <- format(sum(as.numeric(Q3_df_all$entryPrice)), digits=2, nsmall=2)
Q3_averagePeriodOneP <- format(sum(as.numeric(Q3_df_all$periodOnePrice)), digits=2, nsmall=2)
Q3_averagePeriodTwoP <- format(sum(as.numeric(Q3_df_all$periodTwoPrice)), digits=2, nsmall=2)
Q3_averagePeriodThreeP <- format(sum(as.numeric(Q3_df_all$periodThreePrice)), digits=2, nsmall=2)

# CALCULATE THE ONE MONTH RATE OF RETURN
Q3_averagePeriodOne <- format((((as.numeric(Q3_averagePeriodOneP) - as.numeric(Q3_averageEntry)) 
                                / as.numeric(Q3_averageEntry))*100), digits=2, nsmall=2)

# CALCUALTE THE TWO MONTH RATE OF RETURN
Q3_averagePeriodTwo <- format((((as.numeric(Q3_averagePeriodTwoP) - as.numeric(Q3_averageEntry)) 
                                / as.numeric(Q3_averageEntry))*100), digits=2, nsmall=2)

# CALCULATE THE THREE MONTH RATE OF RETURN
Q3_averagePeriodThree <- format((((as.numeric(Q3_averagePeriodThreeP) - as.numeric(Q3_averageEntry)) 
                                  / as.numeric(Q3_averageEntry))*100), digits=2, nsmall=2)

# BUILD THE OUTPUT DATA
Q3_sector_average_text <- sprintf('%s - %s', Q3_Quarter, Q3_SECTOR)
Q3_sector_CRS_averages <- cbind(Q3_sector_average_text,
                                Q3_averageEntry, 
                                Q3_averagePeriodOneP, 
                                Q3_averagePeriodTwoP, 
                                Q3_averagePeriodThreeP, 
                                Q3_averagePeriodOne, 
                                Q3_averagePeriodTwo, 
                                Q3_averagePeriodThree)

colnames(Q3_sector_CRS_averages) <- c("sector_average_text","averageEntry", "averagePeriodOneP", "averagePeriodTwoP", "averagePeriodThreeP", "averagePeriodOne", "averagePeriodTwo", "averagePeriodThree")

# SP500 RETURN CALCULATIONS
Q3_SP500periodOnereturnRate <- rateOfReturn(Q3_sp500_allPeriods$SP500periodOne, Q3_sp500_allPeriods$Entry)
Q3_SP500periodTworeturnRate <- rateOfReturn(Q3_sp500_allPeriods$SP500periodTwo, Q3_sp500_allPeriods$Entry)
Q3_SP500periodThreereturnRate <- rateOfReturn(Q3_sp500_allPeriods$SP500periodThree, Q3_sp500_allPeriods$Entry)

Q3_sp500results <- cbind(c("Q3 - S&P 500"), Q3_sp500_allPeriods, Q3_SP500periodOnereturnRate, Q3_SP500periodTworeturnRate, Q3_SP500periodThreereturnRate)

colnames(Q3_sp500results) <- c("sector_average_text","averageEntry", "averagePeriodOneP", "averagePeriodTwoP", "averagePeriodThreeP", "averagePeriodOne", "averagePeriodTwo", "averagePeriodThree")

sector_CRS_averages <- rbind(sector_CRS_averages, line_space)
sector_CRS_averages <- rbind(sector_CRS_averages, Q3_sector_CRS_averages)
sector_CRS_averages <- rbind(sector_CRS_averages, Q3_sp500results)



#######
# Q4
#######

# CALCULATE THE ONE YEAR RATE OF RETURN
Q4_periodOneReturnRate <- rateOfReturn(Q4_backtestingPrices$periodOnePrice, Q4_backtestingPrices$entryPrice)

# CALCUALTE THE THREE YEAR RATE OF RETURN
Q4_periodTwoReturnRate <- rateOfReturn(Q4_backtestingPrices$periodTwoPrice, Q4_backtestingPrices$entryPrice)

# CALCULATE THE FIVE YEAR RATE OF RETURN
Q4_periodThreeReturnRate <- rateOfReturn(Q4_backtestingPrices$periodThreePrice, Q4_backtestingPrices$entryPrice)

# BIND EACH CALCULATED RATE OF CHANGE AS COLUMNS
Q4_returnResults <- cbind(Q4_DMUnames, 
                          Q4_backtestingPrices$entryPrice,
                          Q4_backtestingPrices$periodOnePrice, 
                          Q4_backtestingPrices$periodTwoPrice,
                          Q4_backtestingPrices$periodThreePrice,
                          Q4_periodOneReturnRate, 
                          Q4_periodTwoReturnRate, 
                          Q4_periodThreeReturnRate)

# SET THE COLUMN NAMES OF THE RATE OF RETURN RESULTS
colnames(Q4_returnResults) <- c("DMU",
                                "entryPrice",
                                "periodOnePrice",
                                "periodTwoPrice",
                                "periodThreePrice",
                                "periodOne",
                                "periodTwo",
                                "periodThree")

# MERGE THE EFFICIENT DMU DATAFRAME WITH THE RATE OF RETURN RESULT DATAFRAME
# NOTE: INNER JOIN BY DMU NAME

# GET THE DMU AND EFFICIENCY SCORE
Q4_temp_MM <- Q4_only_efficient_stocks_MM[,1:2]

# NAME THE TEMP COLUMNS
colnames(Q4_temp_MM) <- c("DMU","Score")

# SLICE OFF ONLY THE STOCKS THAT HAVE AN EFFICIENCY OF ONE (1)
Q4_only_efficient_stocks_RETURNS <- Q4_temp_MM[Q4_temp_MM[,2] >= 1.0,]

# MERGE: INNER JOIN THE DATAFRAMES FOR BACKTESTING VALUES AND EFFICIENT DMUs
Q4_df_all = merge(x = Q4_only_efficient_stocks_RETURNS, y = Q4_returnResults, by = "DMU")

# CREATE THE CAPTION FOR THE REPORT USING THE SECTOR NAME SELECTED FOR STUDY
Q4_report_caption <- sprintf('%s %s Sector Portfolio Detail', Q4_Quarter, toupper(Q4_SECTOR))

# OUTPUT THE DMU, EFFICENCY SCORE, AND RATE OF RETURNS
kbl(Q4_df_all, align = "lcrrrrrrr", booktabs=T, digits=4, escape=F, row.names=F,
    col.names=c("DMU", "Score $\\theta^{CRS}$", "Entry", "1 MO" ,"2 MO" ,"3 MO" , "1 MO", "2 MO", "3 MO"),
    caption= Q4_report_caption) |>
  add_header_above(c(" " = 1, "Efficiency" = 1, "Stock Prices ($)" = 4, "Holding Period Returns (%)" = 3))  |>
  kable_styling(latex_options = c("HOLD_position", "scale_down"))


############################################################################
# GET THE CROSS-EFFICIENCY SCORES FROM THE MULTIPLIERDEA LIBRARY FUNCTION
############################################################################
#eff_result <- DeaMultiplierModel(xdata, ydata , "crs", "input")
#cross_result <- CrossEfficiency(xdata, ydata, "crs", "input")
#rownames(eff_result$Efficiency) <- Q1_DMUnames
###########################################################################

# CALCULATE NUMERICAL PRICE RETURNS
Q4_averageEntry <- format(sum(as.numeric(Q4_df_all$entryPrice)), digits=2, nsmall=2)
Q4_averagePeriodOneP <- format(sum(as.numeric(Q4_df_all$periodOnePrice)), digits=2, nsmall=2)
Q4_averagePeriodTwoP <- format(sum(as.numeric(Q4_df_all$periodTwoPrice)), digits=2, nsmall=2)
Q4_averagePeriodThreeP <- format(sum(as.numeric(Q4_df_all$periodThreePrice)), digits=2, nsmall=2)

# CALCULATE THE ONE MONTH RATE OF RETURN
Q4_averagePeriodOne <- format((((as.numeric(Q4_averagePeriodOneP) - as.numeric(Q4_averageEntry)) 
                                / as.numeric(Q4_averageEntry))*100), digits=2, nsmall=2)

# CALCUALTE THE TWO MONTH RATE OF RETURN
Q4_averagePeriodTwo <- format((((as.numeric(Q4_averagePeriodTwoP) - as.numeric(Q4_averageEntry)) 
                                / as.numeric(Q4_averageEntry))*100), digits=2, nsmall=2)

# CALCULATE THE THREE MONTH RATE OF RETURN
Q4_averagePeriodThree <- format((((as.numeric(Q4_averagePeriodThreeP) - as.numeric(Q4_averageEntry)) 
                                  / as.numeric(Q4_averageEntry))*100), digits=2, nsmall=2)

# BUILD THE OUTPUT DATA
Q4_sector_average_text <- sprintf('%s - %s', Q4_Quarter, Q4_SECTOR)
Q4_sector_CRS_averages <- cbind(Q4_sector_average_text,
                                Q4_averageEntry, 
                                Q4_averagePeriodOneP, 
                                Q4_averagePeriodTwoP, 
                                Q4_averagePeriodThreeP, 
                                Q4_averagePeriodOne, 
                                Q4_averagePeriodTwo, 
                                Q4_averagePeriodThree)

colnames(Q4_sector_CRS_averages) <- c("sector_average_text","averageEntry", "averagePeriodOneP", "averagePeriodTwoP", "averagePeriodThreeP", "averagePeriodOne", "averagePeriodTwo", "averagePeriodThree")

# SP500 RETURN CALCULATIONS
Q4_SP500periodOnereturnRate <- rateOfReturn(Q4_sp500_allPeriods$SP500periodOne, Q4_sp500_allPeriods$Entry)
Q4_SP500periodTworeturnRate <- rateOfReturn(Q4_sp500_allPeriods$SP500periodTwo, Q4_sp500_allPeriods$Entry)
Q4_SP500periodThreereturnRate <- rateOfReturn(Q4_sp500_allPeriods$SP500periodThree, Q4_sp500_allPeriods$Entry)

Q4_sp500results <- cbind(c("Q4 - S&P 500"), Q4_sp500_allPeriods, Q4_SP500periodOnereturnRate, Q4_SP500periodTworeturnRate, Q4_SP500periodThreereturnRate)

colnames(Q4_sp500results) <- c("sector_average_text","averageEntry", "averagePeriodOneP", "averagePeriodTwoP", "averagePeriodThreeP", "averagePeriodOne", "averagePeriodTwo", "averagePeriodThree")

sector_CRS_averages <- rbind(sector_CRS_averages, line_space)
sector_CRS_averages <- rbind(sector_CRS_averages, Q4_sector_CRS_averages)
sector_CRS_averages <- rbind(sector_CRS_averages, Q4_sp500results)


###################
# RISK FREE RATE
###################
risk_free_rate <- cbind(c("Risk-free Rate"), " ", " ", " ", " ", format(monthly_bank_rates, nsmall=2, digits=2), format(monthly_bank_rates, nsmall=2, digits=2), format(monthly_bank_rates, nsmall=2, digits=2))

colnames(risk_free_rate) <- c("sector_average_text","averageEntry", "averagePeriodOneP", "averagePeriodTwoP", "averagePeriodThreeP", "averagePeriodOne", "averagePeriodTwo", "averagePeriodThree")

# ADD RISK FREE RATE TO TABLE - BUILD THE FULL OUTPUT RESULTS
sector_CRS_averages <- rbind(sector_CRS_averages, line_space)
sector_CRS_averages <- rbind(sector_CRS_averages, risk_free_rate)

```

### Backtesting Results Summary

The following table interprets the back-testing results for the stock market portfolio constructed based on DEA efficiency scores, focusing on the returns derived from the entry price, 1-month, 2-month, and 3-month holding periods. The analysis compares the performance of the DEA-generated portfolio against the S&P 500 index and the risk-free savings rate over each quarter (Q1, Q2, Q3, and Q4).

```{r GeneratePortfolioSummaryResults, echo=FALSE, message=FALSE, eval=TRUE}

# CREATE THE CAPTION FOR THE REPORT USING THE SECTOR NAME SELECTED FOR STUDY
report_caption <- 'DEA Generated Sector Portfolio Summary'

kbl(sector_CRS_averages, align = "lrrrrrrr", booktabs=T, digits=3, escape=T, 
    row.names=F, longtable=F,
    col.names=c(" ", "Entry", "1 MO", "2 MO", "3 MO", "1 MO", "2 MO", "3 MO"),
    caption= report_caption) |>
  add_header_above(c(" " = 1, "Porfolio Value ($)" = 4, "Holding Period Returns (%)" = 3))  |>
  kable_styling(latex_options = c("HOLD_position", "scale_down"))

```

*Risk-free APY: `r format(current_bank_rates, nsmall=2, digits=2)`%* [18]

\vspace{12pt}

The first and second quarters show robust out-performance compared to the S&P 500 benchmark over all three (3) holding periods. The third quarter under-performs in the first holding period and outperforms in the the second and third periods. The fourth quarter outperforms in this first holding period, but under-performs in the third. In all, the portfolio out-performs the S&P 500 in 9 of the 12 holding periods; out-performing 75% of the time. In addition, the portfolio out-performs the risk-free savings rate in 10 of the 12 holding periods, or 83% of the time.

Similar results are found in the analysis of other sectors. Appendix A includes a summary 
of the return results for the Basic Materials, Communication Services, Consumer Cyclical, Consumer Defensive, and Utilities market sectors for comparison. The majority of holding periods
out-perform the risk-free savings rate and out-performs that S&P 500 index half of the time.

The DEA-based sector portfolio, built on the foundation of 100% efficiency-rated stocks, demonstrates fairly good performance across multiple quarters. It has some consistency in out-performing the S&P 500 and the risk-free rate suggesting the potential benefits of incorporating efficiency-driven criteria into stock selection for portfolio construction.

As stock prices and return rates evolve over the 1-month, 2-month, and 3-month horizons, the portfolio can be dynamically adjusted based on ongoing DEA assessments. This adaptability ensures that the portfolio remains aligned with the most efficient stock choices in the ever-changing market conditions. The stock market is influenced by numerous factors, and efficiency scores obtained from a specific period may not guarantee consistent performance over time.

The back-testing results provide valuable insights into the relationship between DEA-derived efficiency scores, stock prices, and return rates. The inclusion of stocks with a 100% efficiency rating forms the foundation for constructing a resilient and adaptive portfolio. By considering the dynamic interactions between efficiency, prices, and returns, this research contributes to the development of a strategy that aligns with the goals of efficiency and profitability in stock market investments.

\newpage

# Conclusion

In conclusion, this study navigates the complexities of stock market investing, recognizing the inherent risks associated with external factors, market dynamics, and unforeseen shocks. The vastness of the stock market, comprising numerous stocks across diverse sectors and indices, presents a considerable challenge for investors aiming to select profitable stocks.

Utilizing DEA as a powerful tool, this research narrows its focus to the `r Q1_SECTOR` sector, aiming to identify and combine 100% efficient stocks for the creation of an outperforming portfolio. The study adopts both technical and fundamental indicators within the DEA model, acknowledging the short-term nature of stock trading and the need to capture external forces influencing market prices.

The back-testing methodology, spanning 1-month, 2-month, and 3-month holding periods, scrutinizes the efficiency-driven portfolio against the S&P 500 index. Results are measured not only against market benchmarks but also the risk-free savings rate, providing a comprehensive assessment of the portfolio's performance.

The research successfully incorporates a mix of technical and fundamental variables, building on prior studies' methodologies. Back-testing outcomes reveal the effectiveness of the DEA model in generating a positive return stock portfolio. The consistent application of this method across each quarter ensures a comprehensive evaluation, considering the evolving dynamics of the stock market.

The study systematically discusses the DEA model's variables, including both technical (Beta, Sigma, 1-Month Return Rate) and fundamental (Debt to Equity, Price to Book, Earnings per Share, Return on Assets, Return on Equity, Net Profit Margin) indicators. It emphasizes the importance of integrating these variables within a DEA model to construct a robust stock portfolio.

Analyzing efficiency results through a constant returns scale approach, the research meticulously conducts back-testing to validate the portfolio's performance. The comparison with market benchmarks sets a clear standard, determining whether the portfolio outperforms, matches, or under-performs the market.

In summary, this research contributes to the discourse on utilizing DEA in stock market portfolio construction, shedding light on the nuanced relationship between efficiency scores, stock prices, and holding period return rates. The findings empower investors with valuable insights into crafting portfolios that not only meet but exceed market expectations, ultimately enhancing the decision-making process in stock market investments.

\newpage

# References

[1] Hayes, Adam. How Does the Stock Market Work? Finance. Investopedia. Accessed July 15, 2023. https://www.investopedia.com/articles/investing/082614/how-stock-market-works.asp.

[2] Anderson, Timothy R. Data Envelopment Analysis Using R. Portland State University, n.d.

[3] Folger, Jean. Investing vs. Trading: Whats the Difference? Finance. Investopedia. Accessed July 9, 2023. https://www.investopedia.com/ask/answers/12/difference-investing-trading.asp.

[4] Majaski, Christina. Understanding Fundamental vs. Technical Analysis. Finance. Investopedia. Accessed July 16, 2023. https://www.investopedia.com/ask/answers/difference-between-fundamental-and-technical-analysis/.

[5] Elmerraji, Jonas. Analyze Investments Quickly With Ratios. Finance. Guide to Financial Ratios. Accessed July 28, 2023. https://www.investopedia.com/articles/stocks/06/ratios.asp.

[6] Arasu, B. Senthil, Desti Kannaiah, Nancy Christina J., and Malik Shahzad Shabbir. Selection of Variables in Data Envelopment Analysis for Evaluation of Stock Performance. Management and Labour Studies 46, no. 3 (August 2021): 33753. https://doi.org/10.1177/0258042X211002511.

[7] Chen, James. Backtesting: Definition, How It Works, and Downsides. Finance. Investopedia. Accessed August 3, 2023. https://www.investopedia.com/terms/b/backtesting.asp.

[8] Beers, Brian. Why Do Investors Use the S&P 500 as a Benchmark? Finance. Investopedia. Accessed August 3, 2023. https://www.investopedia.com/ask/answers/041315/what-are-pros-and-cons-using-sp-500-benchmark.asp.

[9] Chen, Hong-Yi, Cheng-Few Lee, and Wei K. Shih. Technical, Fundamental, and Combined Information for Separating Winners from Losers. Pacific-Basin Finance Journal 39 (September 2016): 22442. https://doi.org/10.1016/j.pacfin.2016.06.008.

[10] Chen, HsinHung. Stock Selection Using Data Envelopment Analysis. Industrial Management & Data Systems 108, no. 9 (October 31, 2008): 125568. https://doi.org/10.1108/02635570810914928.

[11] Lioudis, Nick. How to Calculate Beta in Excel. How to Calculate Beta in Excel. Accessed July 28, 2023. https://www.investopedia.com/articles/investing/102115/what-beta-and-how-calculate-beta-excel.asp.

[12] Jim, Zehad. How to Calculate Sigma in Excel (3 Effective Methods). exceldemy. Accessed July 28, 2023. https://www.exceldemy.com/how-to-calculate-sigma-in-excel/.

[13] Fernando, Jason. Debt-to-Equity (D/E) Ratio Formula and How to Interpret It. Finance. Investopedia. Accessed August 5, 2023. https://www.investopedia.com/terms/d/debtequityratio.asp.

[14] McClure, Ben. Using the Price-To-Book (P/B) Ratio to Evaluate Companies. Finance. Investopedia. Accessed August 5, 2023. https://www.investopedia.com/investing/using-price-to-book-ratio-evaluate-companies/.

[15] Fernando, Jason. Earnings Per Share (EPS): What It Means and How to Calculate It. Finance. Investopedia. Accessed August 5, 2023. https://www.investopedia.com/terms/e/eps.asp.

[16] Hargrave, Marshall. Return on Assets (ROA): Formula and Good ROA Defined. Finance. Investopedia. Accessed August 5, 2023. https://www.investopedia.com/terms/r/returnonassets.asp.

[17] Fernando, Jason. Return on Equity (ROE) Calculation and What It Means. Finance. Investopedia. Accessed August 5, 2023. https://www.investopedia.com/terms/r/returnonequity.asp.

[18] Murphy, Chris. What Is Net Profit Margin? Formula for Calculation and Examples. Finance. Investopedia. Accessed August 5, 2023. https://www.investopedia.com/terms/n/net_margin.asp.

[19] Hayes, Adam. Trailing 12 Months (TTM): Definition, Calculation, and How Its Used. Finance. Investopedia. Accessed August 5, 2023. https://www.investopedia.com/terms/t/ttm.asp.

\newpage

# Appendix

## A. Other Market Sector Summary Return Rates

Included below are summary results for portfolios that were generated for sectors other
than `r Q1_SECTOR`. This information shows how other sectors performed in relation
to the S&P 500 and risk-free return rate. 

These sectors are:

  - Basic Materials
  - Communications
  - Consumer Cyclical
  - Consumer Defensive
  - Utilities


**Basic Materials:**

  - 6 of 12 (50%) out-performed the S&P 500.
  - 10 of 12 (83%) out-performed the risk-free savings return rate.
  
```{r AllBasicMaterialsReturnRates, fig.width=7, fig.height=4, echo=FALSE, message=FALSE, eval=TRUE}

img1 <- readPNG("Summary-Include-Images/Basic-Materials-Returns-Summary.png")
grid.raster(img1)

```

\newpage

**Communication Services:**

  - 5 of 12 (42%) out-performed the S&P 500.
  - 7 of 12 (58%) out-performed the risk-free savings return rate.
  
```{r AllCommsReturnRates, fig.width=7, fig.height=4, echo=FALSE, message=FALSE, eval=TRUE}

img2 <- readPNG("Summary-Include-Images/Communications-Returns-Summary.png")
grid.raster(img2)

```

\newpage

**Consumer Cyclical:**

  - 8 of 12 (67%) out-performed the S&P 500.
  - 11 of 12 (92%) out-performed the risk-free savings return rate.
  
```{r AllCyclicalReturnRates, fig.width=7, fig.height=4, echo=FALSE, message=FALSE, eval=TRUE}

img3 <- readPNG("Summary-Include-Images/Cyclical-Returns-Summary.png")
grid.raster(img3)

```

\newpage

**Consumer Defensive:**

  - 6 of 12 (50%) out-performed the S&P 500.
  - 9 of 12 (75%) out-performed the risk-free savings return rate.
  
```{r AllDefensiveReturnRates, fig.width=7, fig.height=4, echo=FALSE, message=FALSE, eval=TRUE}

img4 <- readPNG("Summary-Include-Images/Defensive-Returns-Summary.png")
grid.raster(img4)

```

\newpage

**Utilities:**

  - 5 of 12 (42%) out-performed the S&P 500.
  - 9 of 12 (75%) out-performed the risk-free savings return rate.
  
```{r AllUtilitesReturnRates, fig.width=7, fig.height=4, echo=FALSE, message=FALSE, eval=TRUE}

img5 <- readPNG("Summary-Include-Images/Utilities-Returns-Summary.png")
grid.raster(img5)

```


## B. Graphs and Charts

The charts for the S&P 500, `r Q1_SECTOR` Sector, and efficient stocks selected
to be included within each quarterly portfolio are shown below.

### S&P 500 Chart (Q1-Q4)

```{r, Q1SectorCharts, echo=FALSE, message=FALSE, eval=TRUE}

#####
# Q1
#####

# SECTOR FOR ANALYSIS
Q1_ticker_SECTOR <- switch( 
  Q1_SECTOR,
  "Basic Materials" = "XLB", 
  "Communication Services" = "XTL", 
  "Consumer Cyclical" = "XLY", 
  "Consumer Defensive" = "XLP", 
  "Energy" = "XLE", 
  "Financial Services" = "XLF",
  "Healthcare" = "XLV",
  "Industrials" = "XLI",
  "Real Estate" = "XLRE",
  "Technology" = "XLK",
  "Utilities" = "XLU"
) 

#Q1_tickers = c("^GSPC", Q1_ticker_SECTOR)
Q1_tickers = c("^GSPC")

# OPTIONAL - GET STOCK PRICES FROM YAHOO
Q1_sector_plot <- tq_get(Q1_tickers,
                 from = Q1_FirstDayQuarter,
                 to = Q4_EndDate,
                 get = "stock.prices")

Q1_plot_title <- sprintf('S&P 500 (Q1-Q4)')

# PLOT MULTIPLE FRAMES, ONE FOR EACH TICKER SYMBOL
Q1_sector_plot  %>%
  ggplot(aes(x = date, y = close, color = symbol)) +
  geom_line() +
  facet_wrap(~symbol,scales = 'free_y') +
  theme_tq() +
  labs(x = "Months",
       y = "Close",
       title = Q1_plot_title) +
  scale_x_date(date_breaks = "month",
               date_labels = "%b\n%Y")

```

### `r Q1_SECTOR` Sector Chart (Q1-Q4)

```{r, Q2SectorCharts, echo=FALSE, message=FALSE, eval=TRUE}
#####
# Q2
#####

# SECTOR FOR ANALYSIS
Q2_ticker_SECTOR <- switch( 
  Q2_SECTOR,
  "Basic Materials" = "XLB", 
  "Communication Services" = "XTL", 
  "Consumer Cyclical" = "XLY", 
  "Consumer Defensive" = "XLP", 
  "Energy" = "XLE", 
  "Financial Services" = "XLF",
  "Healthcare" = "XLV",
  "Industrials" = "XLI",
  "Real Estate" = "XLRE",
  "Technology" = "XLK",
  "Utilities" = "XLU"
) 

#Q2_tickers = c("^GSPC", Q2_ticker_SECTOR)
Q2_tickers = c(Q2_ticker_SECTOR)

# OPTIONAL - GET STOCK PRICES FROM YAHOO
Q2_sector_plot <- tq_get(Q2_tickers,
                 from = Q1_FirstDayQuarter,
                 to = Q4_EndDate,
                 get = "stock.prices")

Q2_plot_title <- sprintf('%s Sector (Q1-Q4)', Q2_SECTOR)

# PLOT MULTIPLE FRAMES, ONE FOR EACH TICKER SYMBOL
Q2_sector_plot  %>%
  ggplot(aes(x = date, y = close, color = symbol)) +
  geom_line() +
  facet_wrap(~symbol,scales = 'free_y') +
  theme_tq()+
  labs(x = "Months",
       y = "Close",
       title = Q2_plot_title) +
  scale_x_date(date_breaks = "month",
               date_labels = "%b\n%Y")

```



```{r ShowStockPortfolioCharts, echo=FALSE, message=FALSE, eval=FALSE}

### Stock Portfolio Stock Charts (Q1-Q4)

######
# Q1
######

Q1_plot_title <- sprintf("%s Potfolio Stock Charts", Q1_Quarter)
Q1_plot_x_label <- sprintf("%s", Q1_Quarter)

# OPTIONAL - GET STOCK PRICES FROM YAHOO
#Q1_prices <- tq_get(Q1_only_efficient_stocks_MM[,1],
#                 from = Q1_FirstDayQuarter,
#                 to = Q1_EndDate,
#                 get = "stock.prices")

# QUOTE ALL SYMBOLS FOR USE IN MYSQL 'IN' CLAUSE
Q1_quoted_list <- sprintf('"%s"', Q1_only_efficient_stocks_MM[,1])

sql_select <- sprintf("
SELECT date, open, high, low, close, symbol FROM equity_prices
WHERE symbol IN (%s)
AND date BETWEEN '%s' AND '%s'", toString(Q1_quoted_list), Q1_FirstDayQuarter,
Q1_EndDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q1_prices = as.tibble(fetch(rs, n=-1)) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

# ENSURE TIBBLE DATE IS IN DATE FORMAT
Q1_prices$date <- as.Date(Q1_prices$date)

#theme_classic() 
#geom_candlestick(aes(open = open, high = high, low = low, close = close)) +
  
# PLOT MULTIPLE FRAMES, ONE FOR EACH TICKER SYMBOL
Q1_prices %>%
  ggplot(aes(x = date, y = close, color = symbol, open=open, high=high, low=low, close=close)) +
  geom_line() +
  facet_wrap(~symbol,scales = 'free_y') +
  theme_tq() +
  labs(x = Q1_plot_x_label,
       y = "Close",
       title = Q1_plot_title) +
  scale_x_date(date_breaks = "month",
               date_labels = "%b\n%Y")

######
# Q2
######

Q2_plot_title <- sprintf("%s Potfolio Stock Charts", Q2_Quarter)
Q2_plot_x_label <- sprintf("%s", Q2_Quarter)

#Q2_prices <- tq_get(Q2_only_efficient_stocks_MM[,1],
#                 from = Q2_FirstDayQuarter,
#                 to = Q2_EndDate,
#                 get = "stock.prices")

Q2_quoted_list <- sprintf('"%s"', Q2_only_efficient_stocks_MM[,1])

sql_select <- sprintf("
SELECT date, close, symbol FROM equity_prices
WHERE symbol IN (%s)
AND date BETWEEN '%s' AND '%s'", toString(Q2_quoted_list), Q2_FirstDayQuarter,
Q2_EndDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q2_prices = as.tibble(fetch(rs, n=-1)) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

Q2_prices$date <- as.Date(Q2_prices$date)

# PLOT MULTIPLE FRAMES, ONE FOR EACH TICKER SYMBOL
Q2_prices %>%
  ggplot(aes(x = date, y = close, color = symbol)) +
  geom_line() +
  facet_wrap(~symbol,scales = 'free_y') +
  theme_tq() +
  labs(x = Q2_plot_x_label,
       y = "Close",
       title = Q2_plot_title) +
  scale_x_date(date_breaks = "month",
               date_labels = "%b\n%Y")

######
# Q3
######

Q3_plot_title <- sprintf("%s Potfolio Stock Charts", Q3_Quarter)
Q3_plot_x_label <- sprintf("%s", Q3_Quarter)

#Q3_prices <- tq_get(Q3_only_efficient_stocks_MM[,1],
#                 from = Q3_FirstDayQuarter,
#                 to = Q3_EndDate,
#                 get = "stock.prices")

Q3_quoted_list <- sprintf('"%s"', Q3_only_efficient_stocks_MM[,1])

sql_select <- sprintf("
SELECT date, close, symbol FROM equity_prices
WHERE symbol IN (%s)
AND date BETWEEN '%s' AND '%s'", toString(Q3_quoted_list), Q3_FirstDayQuarter,
Q3_EndDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q3_prices = as.tibble(fetch(rs, n=-1)) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

Q3_prices$date <- as.Date(Q3_prices$date)

# PLOT MULTIPLE FRAMES, ONE FOR EACH TICKER SYMBOL
Q3_prices %>%
  ggplot(aes(x = date, y = close, color = symbol)) +
  geom_line() +
  facet_wrap(~symbol,scales = 'free_y') +
  theme_tq() +
  labs(x = Q3_plot_x_label,
       y = "Close",
       title = Q3_plot_title) +
  scale_x_date(date_breaks = "month",
               date_labels = "%b\n%Y")

######
# Q4
######

Q4_plot_title <- sprintf("%s Potfolio Stock Charts", Q4_Quarter)
Q4_plot_x_label <- sprintf("%s", Q4_Quarter)

#Q4_prices <- tq_get(Q4_only_efficient_stocks_MM[,1],
#                 from = Q4_FirstDayQuarter,
#                 to = Q4_EndDate,
#                 get = "stock.prices")

Q4_quoted_list <- sprintf('"%s"', Q4_only_efficient_stocks_MM[,1])

sql_select <- sprintf("
SELECT date, close, symbol FROM equity_prices
WHERE symbol IN (%s)
AND date BETWEEN '%s' AND '%s'", toString(Q4_quoted_list), Q4_FirstDayQuarter,
Q4_EndDate);

rs = dbSendQuery(mydb, sql_select) # RUN THE QUERY
Q4_prices = as.tibble(fetch(rs, n=-1)) # GET THE DATA FROM THE QUERY RESULTS  
db_temp <- dbClearResult(rs) # FLUSH THE BUFFER, RESULTS INTO TEMP VAR

Q4_prices$date <- as.Date(Q4_prices$date)

# PLOT MULTIPLE FRAMES, ONE FOR EACH TICKER SYMBOL
Q4_prices %>%
  ggplot(aes(x = date, y = close, color = symbol)) +
  geom_line() +
  facet_wrap(~symbol,scales = 'free_y') +
  theme_tq() +
  labs(x = Q4_plot_x_label,
       y = "Close",
       title = Q4_plot_title) +
  scale_x_date(date_breaks = "month",
               date_labels = "%b\n%Y")

```

## C. Correlation Analysis (EPS, Trailing Returns)

### Correlation with Earnings per Share (EPS)

```{r EPScorrelation, echo=FALSE, message=FALSE}

# REGRESSION ANALYSIS FOR REPSPONSE VARIABLE EARNINGS PER SHARE
EPS_Correlation <- reg_brief(data=df_Q1, EPS ~ Sigma + DToE + PToB + NetMrgn + TTMreturn + ROA + ROE + Beta, quiet=TRUE)

```

Correlation with EPS:

Sigma and ROE appear to have the most correlation.
Between variables, Sigma, ROE, and EPS may have a collinear relationship.

### Correlation with Trailing Period Returns

```{r TTMcorrelation, echo=FALSE, message=FALSE}

# REGRESSION ANALYSIS FOR RESPONSE VARIABLE TRAILING RETURNS
TTM_Correlation <- reg_brief(data=df_Q1, TTMreturn ~ Sigma + DToE + PToB + NetMrgn + EPS + ROA + ROE + Beta, quiet=TRUE)

```

Correlation with Trailing Returns:

Not much correlation with any of the variables and the Traling Return rate.
Sigma and EPS may have a collinear relationship, as do Sigma, DtoE, and EPS with ROE.

## D. Parameters Used for Quarterly Data

The sector, fiscal year, and dates used for the analysis follow. The specified dates
are for days when the stock market is open for trading; Monday - Friday,
excluding Federal holidays.

**Q1 Parameters:**

Stock Sector:   `r Q1_SECTOR`

Fiscal Year:    `r Q1_FiscalYear`

Quarter:        `r Q1_Quarter`

1st Day of `r Q1_Quarter`: `r Q1_FirstDayQuarter`

Month Name:     `r Q1_MonthName`

Start Date:     `r Q1_StartDate`

End Date:       `r Q1_EndDate`

Holding Period 1 End Date: `r Q1_periodOneDate`

Holding Period 2 End Date: `r Q1_periodTwoDate`

Holding Period 3 End Date: `r Q1_periodThreeDate`

**Q2 Parameters:**

Stock Sector:   `r Q2_SECTOR`

Fiscal Year:    `r Q2_FiscalYear`

Quarter:        `r Q2_Quarter`

1st Day of `r Q2_Quarter`: `r Q2_FirstDayQuarter`

Month Name:     `r Q2_MonthName`

Start Date:     `r Q2_StartDate`

End Date:       `r Q2_EndDate`

Holding Period 1 End Date: `r Q2_periodOneDate`

Holding Period 2 End Date: `r Q2_periodTwoDate`

Holding Period 3 End Date: `r Q2_periodThreeDate`

**Q3 Parameters:**

Stock Sector:   `r Q3_SECTOR`

Fiscal Year:    `r Q3_FiscalYear`

Quarter:        `r Q3_Quarter`

1st Day of `r Q3_Quarter`: `r Q3_FirstDayQuarter`

Month Name:     `r Q3_MonthName`

Start Date:     `r Q3_StartDate`

End Date:       `r Q3_EndDate`

Holding Period 1 End Date: `r Q3_periodOneDate`

Holding Period 2 End Date: `r Q3_periodTwoDate`

Holding Period 3 End Date: `r Q3_periodThreeDate`

**Q4 Parameters:**

Stock Sector:   `r Q4_SECTOR`

Fiscal Year:    `r Q4_FiscalYear`

Quarter:        `r Q4_Quarter`

1st Day of `r Q4_Quarter`: `r Q4_FirstDayQuarter`

Month Name:     `r Q4_MonthName`

Start Date:     `r Q4_StartDate`

End Date:       `r Q4_EndDate`

Holding Period 1 End Date: `r Q4_periodOneDate`

Holding Period 2 End Date: `r Q4_periodTwoDate`

Holding Period 3 End Date: `r Q4_periodThreeDate`



```{r ShowOutputData, echo=FALSE, message=FALSE, eval=FALSE}

## Source Input Data (Quarterly X Datasets)

x_out <- cbind(df_Q1['DMU'], Q1_x)

# SHOW THE INPUT VARIABLES
kbl(x_out, booktabs=T, digits=3, escape=T, row.names=F, longtable=T,
    col.names=c("DMU","Beta", "Sigma", "Debt To Equity","Price to Book"),
    caption= 'Q1 Data - INPUTS ($x$)')  |>
  kable_styling(latex_options = c("HOLD_position", "repeat_header"))

x_out <- cbind(df_Q2['DMU'], Q2_x)

# SHOW THE INPUT VARIABLES
kbl(x_out, booktabs=T, digits=3, escape=T, row.names=F, longtable=T,
    col.names=c("DMU","Beta", "Sigma", "Debt To Equity","Price to Book"),
    caption= 'Q2 Data - INPUTS ($x$)')  |>
  kable_styling(latex_options = c("HOLD_position", "repeat_header"))

x_out <- cbind(df_Q3['DMU'], Q3_x)

# SHOW THE INPUT VARIABLES
kbl(x_out, booktabs=T, digits=3, escape=T, row.names=F, longtable=T,
    col.names=c("DMU","Beta", "Sigma", "Debt To Equity","Price to Book"),
    caption= 'Q3 Data - INPUTS ($x$)')  |>
  kable_styling(latex_options = c("HOLD_position", "repeat_header"))

x_out <- cbind(df_Q4['DMU'], Q4_x)

# SHOW THE INPUT VARIABLES
kbl(x_out, booktabs=T, digits=3, escape=T, row.names=F, longtable=T,
    col.names=c("DMU","Beta", "Sigma", "Debt To Equity","Price to Book"),
    caption= 'Q4 Data - INPUTS ($x$)')  |>
  kable_styling(latex_options = c("HOLD_position", "repeat_header"))

```


```{r ShowInputData, echo=FALSE, message=FALSE, eval=FALSE}

## Source Output Data (Y Dataset)

y_out <- cbind(df_Q1['DMU'], Q1_y)

# SHOW THE OUTPUT VARIABLES
kbl(y_out, booktabs=T, digits=3, escape=T, row.names=F, longtable=T,
    col.names=c("DMU","Net Margin","EPS", "Return on Assets", "Return on Equity",
                "Rate of Return"),
    caption= 'Q1 Data - OUTPUTS ($y$)')  |>
  kable_styling(latex_options = c("HOLD_position", "repeat_header"))

y_out <- cbind(df_Q2['DMU'], Q2_y)

# SHOW THE OUTPUT VARIABLES
kbl(y_out, booktabs=T, digits=3, escape=T, row.names=F, longtable=T,
    col.names=c("DMU","Net Margin","EPS", "Return on Assets", "Return on Equity",
                "Rate of Return"),
    caption= 'Q2 Data - OUTPUTS ($y$)')  |>
  kable_styling(latex_options = c("HOLD_position", "repeat_header"))

y_out <- cbind(df_Q3['DMU'], Q3_y)

# SHOW THE OUTPUT VARIABLES
kbl(y_out, booktabs=T, digits=3, escape=T, row.names=F, longtable=T,
    col.names=c("DMU","Net Margin","EPS", "Return on Assets", "Return on Equity",
                "Rate of Return"),
    caption= 'Q3 Data - OUTPUTS ($y$)')  |>
  kable_styling(latex_options = c("HOLD_position", "repeat_header"))

y_out <- cbind(df_Q4['DMU'], Q4_y)

# SHOW THE OUTPUT VARIABLES
kbl(y_out, booktabs=T, digits=3, escape=T, row.names=F, longtable=T,
    col.names=c("DMU","Net Margin","EPS", "Return on Assets", "Return on Equity",
                "Rate of Return"),
    caption= 'Q4 Data - OUTPUTS ($y$)')  |>
  kable_styling(latex_options = c("HOLD_position", "repeat_header"))

```


```{r CleanUp, echo=FALSE, message=FALSE}

db_temp <- dbDisconnect(mydb) # CLOSE THE DATABASE CONNECTION

```
